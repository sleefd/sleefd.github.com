<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Bright Shine]]></title>
  <link href="http://sleefd.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://sleefd.github.com/"/>
  <updated>2014-01-21T20:02:29+08:00</updated>
  <id>http://sleefd.github.com/</id>
  <author>
    <name><![CDATA[slee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hamcrest一瞥]]></title>
    <link href="http://sleefd.github.com/blog/2014/01/21/hamcrest/"/>
    <updated>2014-01-21T19:59:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2014/01/21/hamcrest</id>
    <content type="html"><![CDATA[<p>hamcrest是一个Matcher库，有java版，python,c++版等。它提供了很多比较器用来比较两个对象。其并不是一个测试框架，只是因为Matcher可以在测试断言中用到，而被测试框架和Mock框架集成，比如Junit4,EasyMock.</p>

<p>hamcrest库由两大部分组成:Matcher<T>和Description。<br/>
Matcher体系定义了常用的比较器，比如equal，not，same等，每个core matcher继承BaseMatcher,实现matches方法来做比较。</p>

<p>Description体系用来描述每个Matcher，输出Matcher错误信息。比如expected: is(..), got: ..。</p>

<!-- more -->


<h3>hamcrest core matcher</h3>

<p>参见 org.hamcrest.CoreMatchers<br/>
anyOf(mathcher1,mather2..):   满足任何一个matcher即为真，参数为matchers  <br/>
allOf(matcher1,matcher2...): 满足所有matcher，则为真<br/>
anything(): 永远为真<br/>
any(class<T>): 任何T类型，则为真
equalTo(): 是否相等，使用equals比较
nullValue(): 空值为真
instanceOf(): 判断是否为某个类的实例<br/>
is(matcher): 装饰现有matcher，提高代码可读性<br/>
sameInstance(): 是否为同一实例
assertThat(actual, is(expected)): junit断言和is，提高readability</p>

<p>{% codeblock hamcrest例子 lang:java%}
import org.junit.Test;</p>

<p>import static org.hamcrest.CoreMatchers.*;
import static org.hamcrest.core.IsAnything.any;
import static org.junit.Assert.assertThat;</p>

<p>/<em>*
 * Created by slee on 14-1-21.
 </em>/
public class HamcrestTest {</p>

<pre><code>@Test
public void test_hamcrest_matcher(){
    String s = "test";
    //asserts below are all passed
    assertThat(s ,is("test")); //readable code
    assertThat(s, equalTo("test") );
    assertThat(s , is(equalTo("test"))); //readable code

    assertThat(s, is(not("")));

    assertThat(s, notNullValue());

    assertThat(s, any(String.class));
    assertThat(s, is(any(String.class))); //readable
    assertThat(s, anyOf(nullValue(), is("test")));

    assertThat(s, allOf(notNullValue(), equalTo("test")));

    assertThat(s, is(instanceOf(String.class)));
    assertThat(s ,is(sameInstance("test")));
}
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[junit4可用断言]]></title>
    <link href="http://sleefd.github.com/blog/2014/01/21/junit-assert/"/>
    <updated>2014-01-21T10:47:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2014/01/21/junit-assert</id>
    <content type="html"><![CDATA[<p>参见junit.org.Assert.java<br/>
Assert.java包含在单元测试中可使用的所有断言，断言失败产生fail message。<br/>
该类中的方法都为静态方法，通过静态导入，可增强代码可读性。</p>

<!-- more -->


<p>assertEquals( ):比较期望和实际参数是否相等。基本类型直接比较，Object类型调用equals方法比较。</p>

<p>assertSame():  ==比较，比较引用。</p>

<p>assertTrue():   判断bool值是否为真。</p>

<p>assertFalse():  判断bool值是否为假。</p>

<p>assertNull(): 判断参数是否为空。</p>

<p>assertNot~(): 上述所有断言的相反断言。</p>

<p><strong>assertThat</strong>():  该断言使用了<a href="http://code.google.com/p/hamcrest/">hamcrest</a>提供的Matcher，种类多，可读性强，可取代上述所有断言，建议使用。assertThat(actual, matcher)。比如</p>

<p>assertThat("abc", is("abc"));   <br/>
assertThat(mylist, is(expectedList));</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[适配器模式]]></title>
    <link href="http://sleefd.github.com/blog/2014/01/20/adapter-model/"/>
    <updated>2014-01-20T20:31:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2014/01/20/adapter-model</id>
    <content type="html"><![CDATA[<h4>什么是适配器</h4>

<p>以常见的电源适配器为例：比如手机的充电器
，笔记本电脑的电源。日常供电电压是220v,手机充电器将日常电压转
化成手机能用的电压（5v左右）,手机才能冲进电。
香港的笔记本电压是110v,而大陆的电压是220v,如果要让香港的笔记本电脑能在大陆充电要怎么做呢？
需要一个适配器将220v的电压输入转为110v输出，如此笔记本电脑才能充电。</p>

<!-- more -->


<p>因此适配器是一个转换器，将一种输入转化成另一种输出，将一个接口转化成另一个接口，
以较小的代价实现功能的复用。</p>

<h4>适配器模式及好处</h4>

<p>适配器模式是常见的设计模式之一。通过将现有接口转化成另一个需要的接口，
可以复用第三方组件或现有功能模块，避免重复功能的开发。</p>

<h4>适配器模式的实现方法</h4>

<p>使用适配器模式的目的是提供一个可用的接口。<br/>
因此需要一个接口类，定义我们需要的接口；<br/>
接着需要一个类实现这个接口，提供必须功能。这个类通常被称为Adapter。<br/>
当然还有一个类已经提供了我们所需功能的部分实现，需要被复用，称为Adaptee.<br/>
关键是Adapter如何复用Adaptee的功能。方法有两种：</p>

<ul>
<li>Adapter继承Adaptee<br/>
{% codeblock lang:java %}</li>
</ul>


<p>interface Functions
{</p>

<pre><code>public void f();
</code></pre>

<p>}</p>

<p>class Adaptee
{</p>

<pre><code>public void f(int )
{
    //do something....
}
</code></pre>

<p>}</p>

<p>class Adapter extends Adaptee implements Functions
{</p>

<pre><code>public void f()
{
    this.f(3);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<ul>
<li>Adapter引用Adaptee类，包含一个Adaptee对象成员
{% codeblock lang:java %}</li>
</ul>


<p>class Adapter implements functions
{</p>

<pre><code>private Adaptee obj;
public void f()
{
    obj.f(3);
}
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradle一瞥]]></title>
    <link href="http://sleefd.github.com/blog/2014/01/11/gradle/"/>
    <updated>2014-01-11T22:20:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2014/01/11/gradle</id>
    <content type="html"><![CDATA[<p>gradle是一个自动化够建工具，用groovy语言编写。
通过gradle脚本可以一次性完成很多任务，比如编译，测试， 打jar包，多项目管理，依赖管理等等。</p>

<!--more-->


<h3>task</h3>

<p>task是gradle脚本定义的，一个项目可以执行的任务。</p>

<p>gradle tasks 查看所有可以执行的任务
{% codeblock lang:groovy%}
//定义task
task hello&lt;&lt;{</p>

<pre><code>println "hello world"
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>gradle hello //运行Hello task</p>

<h3>plugin</h3>

<p>plugin是gradle预先设置好的一些task，直接使用plugin就不需要自己code task。
比如java plugin，可以帮忙完成java代码的编译，测试，打jar包。
idea plugin，可以把项目打包成idea工程。<br/>
apply plugin后，gradle tasks查看可使用的task。</p>

<p><strong>使用方法</strong></p>

<p>{% codeblock lang:groovy%}
//gradle.build
apply plugin: "java"
apply plugin: "idea"
{% endcodeblock%}</p>

<p>常见的plugin有:</p>

<ul>
<li>java: 提供java源代码编译，测试，运行，打包等功能</li>
<li>idea: 构建idea工程</li>
<li>eclipse: 构建eclipse工程</li>
<li>jetty: 添加jetty服务器支持</li>
<li>war: web project打包成war包</li>
</ul>


<h3>dependency management</h3>

<p>很多时候项目编译要依赖第三方库，比如测试要使用junit,画图表要用Jfreechart，spring框架需要spring的库等。
gradle可以管理这些依赖，自动下载需要的库。</p>

<p>repositories定义外部依赖的来源。
dependencies定义需要的依赖。</p>

<p>声明外部依赖
{% codeblock lang:groovy %}
//build.gradle
apply plugin: "java"
repositories{</p>

<pre><code>mavenCentral()
</code></pre>

<p>}</p>

<p>dependencies{
compile "com.google.guava:guava:15.0"
testCompile "junit:junit:4.8.2"
}
{% endcodeblock %}</p>

<h3>gradle wrapper</h3>

<p>wrapper是一个task.当项目成员木有安装gradle时，通过gradle wrapper可以自动下载安装gradle.
{% codeblock lang:groovy %}
//build.gradle
task wrapper(type:Wrapper)
{</p>

<pre><code>gradleVersion = "1.4"
</code></pre>

<p>}
{% endcodeblock %}</p>

<h3>example</h3>

<ul>
<li><p>java项目</p>

<ol>
<li><p>创建项目目录,java plugin有约定的项目目录格式:</p>

<p>   src<br/>
   ----main---java<br/>
   ----test---java<br/>
   mkdir src\main\java<br/>
   mkdir src\main\test</p></li>
<li><p>build.gradle
{% codeblock lang:groovy %}</p></li>
</ol>
</li>
</ul>


<p>apply plugin: "java"
apply plugin: "idea"
repositories{</p>

<pre><code>mavenCentral()
</code></pre>

<p>}
dependencies{</p>

<pre><code>testCompile "junit:junit:4.8.2"        
</code></pre>

<p>}
{% endcodeblock %}</p>

<pre><code>3. gradle idea  
  创建idea项目
</code></pre>

<ul>
<li><p>spring项目</p>

<ol>
<li><p>创建项目目录</p>

<p>  src<br/>
  ---main---java<br/>
  ---webapp---WEB-INF---pages<br/>
  ---test---java</p></li>
<li><p>build.gradle    <br/>
{% codeblock lang:groovy %}
  apply plugin: 'java'
  apply plugin: 'idea'
  repositories{
  mavenCentral()  <br/>
  }
  dependencies{
  compile "org.springframework:spring-webmvc:3.2.0.RELEASE"</p>

<p>  testCompile "junit:junit:4.8.2"
  }
{% endcodeblock %}</p></li>
<li>gradle idea</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
