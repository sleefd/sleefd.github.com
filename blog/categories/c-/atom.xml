<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | Bright Shine]]></title>
  <link href="http://sleefd.github.com/blog/categories/c-/atom.xml" rel="self"/>
  <link href="http://sleefd.github.com/"/>
  <updated>2014-01-21T20:02:29+08:00</updated>
  <id>http://sleefd.github.com/</id>
  <author>
    <name><![CDATA[slee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[c++字符串分割]]></title>
    <link href="http://sleefd.github.com/blog/2013/03/24/str-split/"/>
    <updated>2013-03-24T15:42:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/03/24/str-split</id>
    <content type="html"><![CDATA[<p>文件解析，数据提取等都要用到字符串分割方法，笔试题也多有考到。</p>

<p>如果是用java语言编写的话，一般顺手就会敲出StringTokenizer，然后输入部分直接由Scanner类处理。</p>

<p>如将ip地址192.168.0.1解析成四段，可以如此写：</p>

<!-- more -->


<p>{%codeblock sample.java%}
Sanner in = new Scanner("in.txt");
while(in.hasNextLine())
{</p>

<pre><code>String line = in.nextLine();
StringTokenizer st = new StringTokenizer(line , ",");
while(st.haxNext())
{
    System.out.print(st.next() + " ");
}
System.out.println("");
</code></pre>

<p>}
{%endcodeblock%}</p>

<p>如果是用c++的话，有以下三种做法：</p>

<ol>
<li>使用cstring头文件中的strtok函数
{%codeblock split1.cpp%}
char line[20];
char delim[] = “,”;
while(gets(line))
{

<pre><code>char *p = NULL;
p = strtok(line, delim );
while(p!=NULL)
{
    cout &lt;&lt; p &lt;&lt; endl;
    p = strtok(NULL,delim);
}
</code></pre>

<p>}
{% endcodeblock %}</p></li>
<li>使用stdio.h中的sscanf
{% codeblock split2.cpp%}
int a,b,c;
sscanf(line, "%d.%d.%d" ,&amp;a , &amp;b ,&amp;c);
{% endcodeblock %}
sscanf和sprintf是非常有用的函数，应该善用。</li>
<li><p>使用strstr()或strchr()或substr()函数<br/>
用这些函数显然是通过寻找delim出现的位置，来分隔字符串。对delim是单个字符的就比较好写了，多个字符很麻烦吧。<br/>
还是以解析ip地址为例:
{%codeblock split3.cpp%}
char line[20] = "192.168.1";
char part[10];</p>

<p>char <em>start = line;
char </em>p ;
int len = strlen(line);
line[len] = '.'; //字符串最后补一个delim，方便后面操作
while((p = strstr(start,"."))!=NULL)
{</p>

<pre><code> len = p -start;
 strncpy(part,start, len);
 part[len] = '\0';  //strncpy不会自动补'\0'
 start = p+1;
 cout &lt;&lt; part &lt;&lt; endl;
</code></pre>

<p>}
{%endcodeblock %}</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
