<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | Bright Shine]]></title>
  <link href="http://sleefd.github.com/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://sleefd.github.com/"/>
  <updated>2014-01-21T20:02:29+08:00</updated>
  <id>http://sleefd.github.com/</id>
  <author>
    <name><![CDATA[slee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[编程珠玑之蓄水池抽样算法]]></title>
    <link href="http://sleefd.github.com/blog/2013/04/05/reservoir-sampling/"/>
    <updated>2013-04-05T11:44:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/04/05/reservoir-sampling</id>
    <content type="html"><![CDATA[<p><strong>问题来源</strong>:  编程珠玑col1,prob4.</p>

<p><strong>问题定义</strong>：从一个序列中随机取得一个数或k个不重复数</p>

<p><strong>问题求解</strong>：分两种情况：</p>

<ul>
<li>已知序列的长度n：直接使用rand()函数（发现c++0x有 <a href="http://www.cplusplus.com/reference/random/?kw=random">random</a> 头文件）</li>
<li>长度未知: 蓄水池抽样算法
（话说很愁一些算法书，总是直接给出算法，完全不知道怎么想出来的）</li>
</ul>


<!--more-->


<h3>序列长度已知</h3>

<p>1.随机获取一个数</p>

<pre><code>{% codeblock lang:cpp %}
#include&lt;cstdlib&gt;
srand(time(NULL));
int id = rand()%n;
cout &lt;&lt; arr[id] &lt;&lt; endl;
{% endcodeblock %}
</code></pre>

<p>2.随机获取k个不重复数</p>

<pre><code>{% codeblock lang:cpp %}
#include&lt;cstdlib&gt;

// 生成[i,j)间的随机数
int randint(int i , int j)
{
      int a = rand()%(j-i) + i;  
return a;
}
for(int i = 0 ; i&lt;k ; ++i)
{
    swap(i,id = randint(i,n));//swap(i,j)交换i,j下标处的两个数
    cout &lt;&lt; arr[id] &lt;&lt; endl;
}
{% endcodeblock %}
</code></pre>

<p>p.s.在长度已知的情况下，该问题直观上可以用list解决。
选取一个数就从list中删掉，然后再随机生成一个下标（用初始迭代器移动到下标位置，list不支持下标操作）就ok了。</p>

<h3>序列长度未知</h3>

<p>关于蓄水池抽样算法：</p>

<blockquote><p>该算法是针对从一个序列中随机抽取不重复的k个数，保证每个数被抽取到的概率为k/n这个问题而构建的。做法是：  -<br/>
首先构建一个可放k个元素的蓄水池，将序列的前k个元素放入蓄水池中。<br/>
然后从第k+1个元素开始，以k/n的概率来决定该元素是否被替换到池子中。
当遍历完所有元素之后，就可以得到随机挑选出的k个元素。复杂度为O(n).</p></blockquote>

<p>1.随机获取一个数</p>

<pre><code>{% codeblock lang:cpp%}
int n = 0;//统计num的个数
int num;
while(cin&gt;&gt;num)
{
     ++n; 
     int id = rand()%n;
     if(id == 0) //很显然id=0的概率为1/n，也就是每个num被选到的概率是1/n
          res = num;
}
cout &lt;&lt; res  &lt;&lt; endl;
{% endcodeblock %}
</code></pre>

<p>2.随机获取k个不重复数</p>

<pre><code>{% codeblock lang:cpp%}
int res[k]; //蓄水池
int n = k;
for(int i = 0 ;i &lt;k ;++i)//先放k个元素在蓄水池中
{
     cin &gt;&gt; num;
     res[i] = num; 
}
//从第k+1个元素开始
while(cin &gt;&gt; num)
{
     ++n;
     int id = rand()%n;
     if( id &lt; k ) //这一步也很直观，num有k/n的概率被换到蓄水池中
          swap(id, num);//把蓄水池中编号为id的数换成num
}
//蓄水池中的k个数就是最终结果
{% endcodeblock %}
</code></pre>

<p>证明每个数被取到的概率为k/n:</p>

<ol>
<li><p>对于第i个数(i&lt;k)，在前k步被选中的概率是1，
从第k+1步开始，i不被选中的概率为k/k+1,那么读到第n个数时，
第i个数(i&lt;k)被选中的概率 = 被选中的概率 * 以后每一步都不被换走的概率,即<br/>
1 * k/k+1 * k+1/k+2 <em>...</em>n-1/n = k/n</p></li>
<li><p>对于第j个数(j>=k)被选中的概率为：
在他出现时被选中的概率 * 在他出现以后不被换走的概率,即: <br/>
k/j * j /j+1 <em>。。。</em>n-1/n = k/n</p></li>
<li><p>综上得证。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程珠玑之幂函数]]></title>
    <link href="http://sleefd.github.com/blog/2013/01/27/pow/"/>
    <updated>2013-01-27T19:36:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/01/27/pow</id>
    <content type="html"><![CDATA[<p>问题来源：编程珠玑 ,column4, problem 9，修改log（n）内的递归求幂算法为迭代算法。这样才知道求幂有O(log(n))复杂度的算法，sigh。发现很多问题都可以用二分的思想来解决。</p>

<!-- more -->


<p>问题定义：求pow(x,n)，其中n为正整数。<br/>
解法一： 很直观的解法，每个人第一眼看到都会想到。将x乘以n次就ok嘛，一个for循环了事。时间复杂度O(n)。</p>

<ul>
<li>迭代求解    <br/>
{% codeblock pow1.cpp %}
double result = 1;
for(int i = 0 ; i &lt; n ;++i)
result *=x;
return result;
{% endcodeblock %}</li>
<li>递归求解<br/>
{% codeblock pow2.cpp %}
double pow(double x , int n)
{
  if(n == 0) return 1;
  else

<pre><code>  return x * pow(x, n-1);
</code></pre>

}
{% endcodeblock %}<br/>
解法二： pow(2 , 4)以解法一的话，需要做四次乘法，但是如果先计算2*2，再计算4*4,两次乘法ok，即log（n）次乘法。<br/>
{% codeblock %}
  if(n/2 == 0)

<pre><code>  pow(x,n) = square(pow(x , n/2));
</code></pre>

  if(n%2 == 1)

<pre><code>  pow(x,n) = x * pow(x,n-1)
</code></pre>

<p>{% endcodeblock %}</p></li>
<li>递归解法<br/>
{% codeblock pow3.cpp%}
double pow(double x , int n )
{
  if(n == 0) return 1;
  if(n/2 == 0) return square(pow(x,n/2));
  else return x * pow(x , n-1);
}
{% endcodeblock %}</li>
<li>迭代求解<br/>
{% codeblock pow4.cpp %}
int id = 0;
double result = x;
if( n == 0 ) return 1;
while(1)
{
  if(id == n) return result;
  if(id*2 &lt;= n )
  {

<pre><code>  id = id * 2;
  result *= result;
</code></pre>

  }
  else
  {

<pre><code>  id = id + 1;
  result *= x;
</code></pre>

  }
}
{% endcodeblock %}<br/>
测试scaffolding:<br/>
{% codeblock test.cpp %}

<h1>define f pow</h1>

<p>int main()
{
 // cout &lt;&lt; f(2,-1) &lt;&lt; endl; //源代码应该检查指数不为正整数的情况
  cout &lt;&lt; f(2,0) &lt;&lt; endl;
  cout &lt;&lt; f(2,7) &lt;&lt; endl;
  cout &lt;&lt; f(2,8) &lt;&lt; endl;
  return 0;
}
{% endcodeblock %}</p></li>
</ul>


<p>总结： 二分的方法在很多地方都能使用，以后遇到算法优化，首先考虑二分。<br/>
将第二种解法的递归形式改为迭代形式我想了好久。仔细想想，递归是自顶向下的求解方法，
而迭代是自底向上的求解方法，然后枚举出所有的可能情况，就可以很好的写出递归或迭代形式的算法。</p>
]]></content>
  </entry>
  
</feed>
