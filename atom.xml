<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bright Shine]]></title>
  <link href="http://sleefd.github.com/atom.xml" rel="self"/>
  <link href="http://sleefd.github.com/"/>
  <updated>2013-03-07T22:38:01+08:00</updated>
  <id>http://sleefd.github.com/</id>
  <author>
    <name><![CDATA[slee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用markdown写ppt]]></title>
    <link href="http://sleefd.github.com/blog/2013/03/07/markdown-ppt/"/>
    <updated>2013-03-07T20:40:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/03/07/markdown-ppt</id>
    <content type="html"><![CDATA[<h4>why markdown?</h4>

<p>最近一直用markdown写blog，深感markdown易于书写的特性。如果markdown能用于写ppt岂不是更好，再加上<a href="http://johnmacfarlane.net/pandoc/">pandoc</a>这个奇妙的工具，那么所有涉及到书写的工作基本上都可以由markdown完成了。</p>

<!-- more -->


<h4>principle</h4>

<p>偶然在Toplanguage上看到有人用<a href="https://github.com/bartaz/impress.js">impress.js</a>做的html格式的ppt，简洁而且可以直接丢在网上，感觉非常有趣。于是开始研究原理，发现其实很直观：强大的javascript+css3即可以实现很绚丽的ppt效果（其实前端开发也很有挑战性嘛~）。ppt书写可以直接由markdown,html,textile等语言完成，very nice~</p>

<p>花时间研究了一下，发现支持html ppt制作的template很多，比如deck.js,impress.js，reveal.js等等。最后找到了<a href="http://slideshow.rubyforge.org/">slideshow</a>这个ruby gem，易用而且支持上面提到的各种template，特此推荐。</p>

<h4>slideshow</h4>

<p>slideshow可以将markdown或textile等文件解析成ppt，所有的ppt页面都在一个html页中，因此你可以直接把这个html放在自己的网站上，供别人访问。</p>

<p>slideshow安装方法如下：<br/>
1. 安装ruby和ruby gems<br/>
2. gem install slideshow #安装slideshow gem</p>

<p>使用时直接 <code>slideshow test.md</code> 即可将test.md解析成test.html，双击打开就是一个ppt，方向键控制播放,F11全屏浏览，very simple.</p>

<p>与test.html同时生成的还有s6文件夹，包含s6模版文件；test.css，html样式表。<br/>
slideshow默认为s6模版。安装其他模版输入命令以deck.js为例：<br/>
&#8216;slideshow -f deck.js&#8217;</p>

<p>自己做了一个<a href="http://sleefd.github.com/denclue">demo</a>，关于密度聚类算法的ppt。<a href="http://sleefd.github.com/denclue/denclue.md">示例markdown</a>。</p>

<hr>


<p>slideshow参考:<a href="http://slideshow.rubyforge.org/">slideshow</a><br/>
推荐网站 <a href="www.rvl.io.">reveal</a>，支持在线ppt编辑，可直接生成一个在线浏览链接，非常方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译安装第三方lib]]></title>
    <link href="http://sleefd.github.com/blog/2013/02/27/use-third-library/"/>
    <updated>2013-02-27T22:08:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/02/27/use-third-library</id>
    <content type="html"><![CDATA[<h3>编译运行基本步骤</h3>

<p>./comfigure  #生成makefile，configure文件一般是Linux下可执行脚本<br/>
make  #编译<br/>
make install #安装文件<br/>
make uninstall #卸载文件</p>

<!--more-->


<h3>版本</h3>

<p>source distribution 源代码版本。第三方库或软件的源代码，需要自己编译才能使用。<br/>
源代码版本需要经过上述三个步骤才能执行。<br/>
binary distribution 二进制版本即可执行版本，已编译好的，在特点平台上可直接运行安装的。</p>

<h3>平台</h3>

<p>windows下使用源代码版本的软件或库，需要自己写makefile，然后make,make install.平时我们使用复杂的IDE如visual studio等，可以直接编译运行，不需要
自己写makefile，上述三个步骤已由IDE自己完成。</p>

<p>linux下源码包以压缩包的形式存在，需先解压，然后cd到所在目录，再输入上述三个命令即可。
注意阅读源码包中的readme和install文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在log(n)内求幂]]></title>
    <link href="http://sleefd.github.com/blog/2013/01/27/pow/"/>
    <updated>2013-01-27T19:36:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/01/27/pow</id>
    <content type="html"><![CDATA[<p>问题来源：编程珠玑 ,column4, problem 9，修改log（n）内的递归求幂算法为迭代算法。这样才知道求幂有O(log(n))复杂度的算法，sigh。发现很多问题都可以用二分的思想来解决。</p>

<!-- more -->


<p>问题定义：求pow(x,n)，其中n为正整数。<br/>
解法一： 很直观的解法，每个人第一眼看到都会想到。将x乘以n次就ok嘛，一个for循环了事。时间复杂度O(n)。</p>

<ul>
<li>迭代求解</li>
</ul>


<figure class='code'><figcaption><span>pow1.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'> <span class="n">result</span> <span class="o">*=</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>递归求解</li>
</ul>


<figure class='code'><figcaption><span>pow2.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>解法二： pow(2 , 4)以解法一的话，需要做四次乘法，但是如果先计算2*2，再计算4*4,两次乘法ok，即log（n）次乘法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(n/2 == 0)
</span><span class='line'>      pow(x,n) = square(pow(x , n/2));
</span><span class='line'>    if(n%2 == 1)
</span><span class='line'>      pow(x,n) = x * pow(x,n-1)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>递归解法</li>
</ul>


<figure class='code'><figcaption><span>pow3.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>迭代求解</li>
</ul>


<figure class='code'><figcaption><span>pow4.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">*=</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>测试scaffolding:</p>

<figure class='code'><figcaption><span>test.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#define f pow</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="c1">// cout &lt;&lt; f(2,-1) &lt;&lt; endl; //源代码应该检查指数不为正整数的情况</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结： 二分的方法在很多地方都能使用，以后遇到算法优化，首先考虑二分。<br/>
将第二种解法的递归形式改为迭代形式我想了好久。仔细想想，递归是自顶向下的求解方法，
而迭代是自底向上的求解方法，然后枚举出所有的可能情况，就可以很好的写出递归或迭代形式的算法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[四时之景不同，而乐亦无穷也]]></title>
    <link href="http://sleefd.github.com/blog/2013/01/12/donghuxing/"/>
    <updated>2013-01-12T21:37:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/01/12/donghuxing</id>
    <content type="html"><![CDATA[<p>和喵环东湖一周，大概2个半小时吧，挺快的，比平时快多了。<br/>
今天东湖雾很大，一眼看不到太远，虽没有秋天的静谧，没有秋天的金棕色红色，但是薄雾笼罩下的东湖确实别有风味。环湖路上的汽车依然很多，公汽依然不客气，随意的就把我们小折叠挤到路边边。</p>

<!-- more -->


<p>今天天气算暖和了，因此骑车的人很多，折叠山地都有，普通车也有。虽有风，我依然穿了一件抓绒衣，一件马甲，魔术头巾当口罩，轻装出行，很快意。以不快不慢的速度骑行，然后不时能瞟一下湖两边的风景，人生真美好~<br/>
依然是从工学部外的那个桥骑入东湖。没走多远，就看到一对老夫妻在路边很小块的田地里耕田。老奶奶是搬个板凳坐着的，老爷爷站着翻土，画面很和谐。我依然认为乐享天伦之乐是人世间最幸福的事情。<br/>
继续往前走到梅园，正举行东湖2013年梅花节。梅园梅花的品种很多。记得同yuqi翻墙进梅园的那时，梅花还未盛开，但是梅园很静。现在梅花已开，看墙壁上挂的各种梅花图片，还是挺想进去的，但是带着车有诸多不便，于是继续向前。<br/>
然后到磨山风景区入口，有一个自动租借书籍的机器，刷武汉通就可以了，顿时觉得武汉通真好用，不仅能刷地铁还能借杂志，如果以后绕东湖乏了，还能借一两本书，在常去的那小片总是有太阳照射的草地上躺着看看，其实很美。<br/>
喵说想绕整个东湖，我也就没按平时走一部分路然后往回骑，继续向东湖海洋生态馆和听涛景区进发。竟然碰到一个背包徒步游东湖的人，同好呀。改明儿有时间我也来个徒步环东湖，在武汉也只独自一人徒步从信息学部大门一直走到长江大桥过，和小白一起从龟山走到过江滩。<br/>
过了听涛景区之后竟然有点不认识路了，只记得要经过省博一直往前走，于是在路上抓了个阿姨问问。阿姨说也刚到这儿不清楚，然后我们说去武大，她就清楚了，很耐心的为我们指了路，走的时候还不时回头嘱咐我们，所以说这个世界好人是很多的~<br/>
接着遇到一个地下通道不知道要不要下去，又问一阿姨，阿姨的自行车貌似坏了，要推着走，但是还是让我们直接从通道骑下去，不需要跟她一样推，嘿嘿。顺利骑下去然后拐弯。
绕回来的时候又到工学部旁边那条东湖路，竟然看到一个人骑着山地后面带着一个箱子，箱子里面放着他的小狗，真可爱。狗头还伸出箱子外往外望，太有爱了，哈哈。<br/>
总之，骑行过程很舒心，回来之后腰酸腿疼，各种累，某喵同学还吵着要去按摩~哈哈
心在路上，从未停止。</p>

<hr/>


<p>能走不同的路，看不同的风景，有三五好友，还有什么值得追求？<br/>
有一颗自由的心，且能时刻保持着对万物的兴趣与怜悯，还有什么值得拥有？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress博客搭建中问题汇总及解决方法]]></title>
    <link href="http://sleefd.github.com/blog/2012/12/28/build-problems/"/>
    <updated>2012-12-28T20:53:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2012/12/28/build-problems</id>
    <content type="html"><![CDATA[<ol>
<li><p>bundle install时，ffi包装不上：</p>

<p>将gemfile.lock文件中所有涉及到ffi版本号的地方都改为ffi (~>1.1.1)<a href="http://michael-roshen.iteye.com/blog/1613151">【参考】</a><!--more--></p></li>
<li><p>bundle install时，安装某个包提示<code>&gt; ERROR: Failed to build gem native extension.</code></p>

<ul>
<li><a href="http://rubyinstaller.org/downloads/">安装Devkit</a></li>
<li>配置环境变量path为devkit下的bin目录</li>
<li><p>执行代码</p>

<p><code>
ruby dk.rb init<br/>
ruby dk.rb install
</code></p></li>
</ul>
</li>
<li><p>rake generate失败</p>

<ul>
<li>检查_config.yml，注意每个冒号后面都有空格</li>
<li>大多数原因是中文解析问题。<br/>
首先所有的markdown文件应为UTF-8格式，然后修改
你ruby安装目录下的convertible.rb：<br/>
<code>
self.content = File.read(File.join(base, name))改为<br/>
self.content = File.read(File.join(base, name), :encoding => "UTF-8")
</code></li>
</ul>
</li>
<li><p>使用模版的方法：<br/>
RTFM:一定要看模版说明<br/>
通过修改_config.yml中的相关变量来基于模版个性化自己的博客。</p></li>
<li><p>使用<code>&lt;!-- more --&gt;</code>来显示post中的部分内容。该标签后的所有内容将不被显示。</p></li>
<li><p>配置disqus的方法：</p>

<ul>
<li>注册disqus id，配置与你的站点关联，取一个站点shortname，记住它，很重要。</li>
<li>设置_config.yml中disqus部分：<br/>
disqus_short_name: 站点shortname<br/>
disqus_show_comment_count: true</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mex调用c代码备忘]]></title>
    <link href="http://sleefd.github.com/blog/2012/12/28/mex/"/>
    <updated>2012-12-28T16:36:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2012/12/28/mex</id>
    <content type="html"><![CDATA[<ul>
<li>目的：在matlab中调用c函数，加快代码执行速度或实现c代码复用。</li>
<li>媒介：mex file
  有约定俗成的格式，c源文件必须包括头文件 &#8220;mex.h&#8221;, 函数 mexFunction为入口函数.
  当然也可以使用其他符合c语法的函数，头文件。</li>
<li>关键： 各种数据类型在matlab和c之间的转换，传递。</li>
</ul>


<!-- more -->


<ul>
<li>mexFunction的签名为
<code>
  void mexFunction( int nlhs,
   mxArray <em>plhs[],
   int nrhs,
   const mxArray </em>prhs[])
</code>
参数解释：
  nlhs: 输出个数
  nrhs: 输入参数的个数
  plhs: 指向输出的指针数组
  prhs: 指向输入的常指针数组</li>
<li>数据类型：
  matlab传递给c的数据类型都是mxArray类型,matlab的所有数据类型内部都以mxArray的形式存储。(可以猜想mxArray是一个结构体类型。</li>
<li>基本操作：mx/mex函数

<pre><code>   1. *mx开头*的函数为对数据进行操作的函数.
      记住：有Get操作，就有对应的set操作，而且由于操作大多针对指向数据的指针，所以
      set操作可能会改变workspace中的变量。
   2. *mex开头*的函数为与workspace交互的函数，如输出error message ,warning message , printf data等。
</code></pre></li>
</ul>


<h4>代码示例</h4>

<ul>
<li>c从matlab获得数据
  获取matrix:

<pre><code>  double *p = mxGetPr(prhs[0]) ;//得到指向第一个数据参数的指针。 注意：所有包含数值的参数都是double类型。
  只要参数是matrix(m*n)类型，都可以通过mxGetPr得到指向数据的指针，数据以从上到下从左到右的形式存储。（也就是线性的~
</code></pre>

  获取维数：

<pre><code>  `mexGetM(mxarray)/mexGetN(mxarray)： 得到mxArray的row &amp;&amp; column 数`
</code></pre>

<p>  获取cell数据类型：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(int index = 0 ; index &lt; size  ; ++index)
</span><span class='line'>      {
</span><span class='line'>          mxArray * p = mxGetCell(prhs[0] , index); //得到index处的mexArray
</span><span class='line'>          double *elem = mxGetPr(p);
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<pre><code>直接获取data（数值
</code></pre>

<p>`       double *data;</p>

<pre><code>    data = mxGetData(prhs[0]);
    //mxSetData(p1hs[0] , data);
    `
</code></pre>

<ul>
<li>c返回数据给matlab

<pre><code>workspace输出：mexPrintf,类似c printf函数。  mexPrintf("%d\n" , number);
               mexErrMsgTxt,打印error消息。 mexErrMsgTxt("This is an error message.");
               mexEvalString,在workspace中调用string指定的命令。 mexEvalString("plot([1:5])"); //plot命令会被执行
</code></pre>

   想要返回数据给matlab，首先要分配空间给输出数据，这样它才能存在于当前的workspace中。

<pre><code>  分配空间的方法 1 plhs[0] = mxCreateDoubleMatrix(m,n,mxReal);
                  double *data = mxGetPr(plhs[0]); //and then you can assign values to data.
                 2 利用mxMalloc (用法类似c malloc
                  double *data = mxMalloc(sizeof(double) * num);
                      ... //assign values
                  mxSetPr(prhs , data);
</code></pre></li>
<li>动态内存分配:使用mxMalloc/mxFree mxCalloc/mxFree

<pre><code>       虽然c malloc和free也可以使用，但是会导致不可预知的错误，所以谨记使用mex functions.
</code></pre></li>
</ul>


<p>配置mex file编译环境在matlab中：</p>

<pre><code>直接在命令行下输入 mex -setup 选择合适的编译器就ok了。
</code></pre>

<p>调试：可在VS中采用附加进程调试</p>

<p>有价值的资料：</p>

<pre><code>1. apiext.pdf //matlab external interface 
2. mexguide.pdf 
</code></pre>
]]></content>
  </entry>
  
</feed>
