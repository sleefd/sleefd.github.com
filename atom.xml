<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bright Shine]]></title>
  <link href="http://sleefd.github.com/atom.xml" rel="self"/>
  <link href="http://sleefd.github.com/"/>
  <updated>2013-04-13T01:26:16+08:00</updated>
  <id>http://sleefd.github.com/</id>
  <author>
    <name><![CDATA[slee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[网易游戏QA工程师实习生求职经历]]></title>
    <link href="http://sleefd.github.com/blog/2013/04/13/netease-interview/"/>
    <updated>2013-04-13T01:16:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/04/13/netease-interview</id>
    <content type="html"><![CDATA[<p>处女面献给了网易游戏。</p>

<p>我投的是网易游戏qa工程师，先在网上投简历，然后经历了电话面试，当面两轮面试一共三轮面试。比较顺利的拿到了offer.</p>

<!--more-->


<h4>一面: hr电话面试</h4>

<p>简历通过筛选之后，接到了网易广州打来的话，约hr电话面试时间，定在第二天的晚上7点到7点半之间。当时觉得好奇怪，hr面试不是应该放在整个流程的最后面的嘛,但是网易偏偏是一面。嗯，然后在网上找了下面经什么的，发现没有。于是怀着忐忑的心情继续看自己的书，忐忑啊忐忑，然后到了第二天晚上。</p>

<p>晚上7点多的时候接到了hr的来电。首先让我做自我介绍，然后告诉我说以下对她的问题的回答都通过举实例说明。话说我从来没有在电话里面巴拉过这么多话，囧。提到的问题如下:</p>

<ul>
<li>在大学做过的最有成就感的一件事情</li>
<li>你曾经和同伴发生过争吵吗，怎么解决的</li>
<li>举例说明你是如何树立目标并达成的</li>
<li>为什么选择网易，选择这个职位</li>
</ul>


<p>能记得的就这么几个问题，整个时长25分钟左右，大部分时间都是自己在说，hr在听。回答完之后hr告知清明之后会再通知，没有就是没通过电面。</p>

<p>说实话挂电话之后，挺怀疑自己的，感觉回答的不是很清楚，表达能力有限啊。。。</p>

<h4>二面:专业一面（4.10）</h4>

<p>清明之后，接到了网易的电话约面试时间，话说网易工作人员打了三次电话来更改时间，额。最后确定在4.10号下午4点。</p>

<p>下午四点在hust 1号楼等候面试，去了之后才知道1号楼以及8号楼是宾馆，面试官都住在里面。我们全部在会议室里等候，由工作人员负责通知面试地点。提前到了40多分钟，等的很是煎熬。哎。。等的过程中遇到一个同校同院的家伙，超级不喜欢他，不解释。</p>

<p>8号楼701，三个面试官等待着我，2男一女。
刚到就被招呼到沙发上坐下，然后我递出了三份简历。我想说网易的面试官都very nice。整个过程非常轻松。</p>

<p>一个面试官负责问技术问题，包括简历中的项目。</p>

<ul>
<li>面向对象的概念，然后让我对现场的场景建模</li>
<li>c与c++的区别，因为我写了熟悉c++.</li>
<li>tcp/ip协议栈的组成，为什么要分层，我的项目涉及到这个。</li>
<li>复杂网络社区发现是干什么，我的科研经历</li>
<li>推荐系统的实现，多示例学习，我的科研经历</li>
</ul>


<p>女面试官问测试相关的东西:
折叠自行车怎么测试，我写到了喜欢骑行，囧。涉及到压力测试，性能测试啊等等。</p>

<p>还有一个面试官很funny，飙了句日文，我竟然说是粤语，尴尬，哄堂大笑，感觉我就是去搞笑的，哎。他问了两个问题，数理逻辑方面的吧，我都没回答出来，但是有分析。</p>

<ul>
<li><p>两个素数中间的一个数能被6整除嘛？<br/>
抽象一下就是a,a+1,a+2，a和a+2是素数，a+1能被6整除嘛？<br/>
话说这个题不严谨，a应该大于3，否则3，4，5，4明显不能被6整除嘛。<br/>
如果a=3，不能。<br/>
如果a!=3,能。
首先，两个素数中间的数一定是偶数能被2整除。<br/>
下面只需考虑中间数能否被3整除。<br/>
3k-1,3k,3k+1，恰好能表示所有>=2的整数，right?<br/>
素数只能是3k-1,3k+1,中间数一定是3k，能被3整除，故能被6整除。</p></li>
<li><p>这到题你可能在weibo或智力书上看了好几次，反正我是被误导了。<br/>
3个人去住店，每个人出10块钱。老板找他们5块，让自己的小孩去还给他们，然后小孩觉得5块不好分，于是拿走了2块，话说为什么少了一块呢？
三人一共出了27块，被拿走了2块，相当于出了28块啊，那一块哪里去了，这样想就被误导了。。
三个人出了9*3=27块，老板收益25+2=27，ok了。</p></li>
<li><p>桌上一瓶矿泉水，问有什么作用。
武器啊，卖钱啊，装水啊，储物啊，漏斗啊，装饰，插花啊等等。</p></li>
</ul>


<p>总之，整个过程很欢乐- -很嘻哈- -<br/>
晚上接到了第二天的专业二面通知。</p>

<h4>三面（终面）:专业二面（4.11）</h4>

<p>说是专业二面其实没问什么专业的东西，昨天晚上白忐忑了。9:10分的面试，我起了一个大早，因为从WHU赶到HUST要坐40分钟左右的公汽，到hust之后还得坐校车，话说为找实习跑了好多次HUST啊，从来没有这么折腾过。</p>

<p>也是3个面试官，整个过程就是随意的聊聊天。
问了下你想去什么样的公司，你希望你的同事是什么样的，个人的兴趣爱好，你希望从工作中获得什么，很随意，面试官都很nice。</p>

<p>事后回忆自己的回答各种2不解释。我这个2B面完之后又嘻嘻哈哈的回到了学校。（据说最后这一面还有人被刷的。。。我竟然没被刷- -</p>

<p>当天下午就接到网易的通知说过了终面，高兴地从被子里面爬起来奔向hust拿到了offer通知书。</p>

<p>2013.4.11拿到了人生的第一个offer，感谢网易游戏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IKM test]]></title>
    <link href="http://sleefd.github.com/blog/2013/04/07/ikm-test/"/>
    <updated>2013-04-07T22:27:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/04/07/ikm-test</id>
    <content type="html"><![CDATA[<p>晚上做了Morgan stanley的c++在线测评，表示我又要死在这种笔试上了。
全部都是OOP概念题：继承，多态，内部类。逻辑题算法题一点都没有。<br/>
尼玛以后都不好意思说自己会c++了，丢人。<br/>
java的题不做了，估计又全部是oop概念题。</p>

<!-- more -->


<p>伤感，看来要饿补OOP部分，然后总结一下写个list贴在桌上，以后好秒杀。</p>

<p>笔试什么的，做本题库才是王道。</p>

<p>难道我今年注定投哪儿就酱油哪儿？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程珠玑之蓄水池抽样算法]]></title>
    <link href="http://sleefd.github.com/blog/2013/04/05/reservoir-sampling/"/>
    <updated>2013-04-05T11:44:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/04/05/reservoir-sampling</id>
    <content type="html"><![CDATA[<p><strong>问题来源</strong>:  编程珠玑col1,prob4.</p>

<p><strong>问题定义</strong>：从一个序列中随机取得一个数或k个不重复数</p>

<p><strong>问题求解</strong>：分两种情况：</p>

<ul>
<li>已知序列的长度n：直接使用rand()函数（发现c++0x有 <a href="http://www.cplusplus.com/reference/random/?kw=random">random</a> 头文件）</li>
<li>长度未知: 蓄水池抽样算法
（话说很愁一些算法书，总是直接给出算法，完全不知道怎么想出来的）</li>
</ul>


<!--more-->


<h3>序列长度已知</h3>

<p>1.随机获取一个数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="cp">#include&lt;cstdlib&gt;</span>
</span><span class='line'>  <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>2.随机获取k个不重复数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="cp">#include&lt;cstdlib&gt;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// 生成[i,j)间的随机数</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">randint</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">id</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">));</span><span class="c1">//swap(i,j)交换i,j下标处的两个数</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>p.s.在长度已知的情况下，该问题直观上可以用list解决。
选取一个数就从list中删掉，然后再随机生成一个下标（用初始迭代器移动到下标位置，list不支持下标操作）就ok了。</p>

<h3>序列长度未知</h3>

<p>关于蓄水池抽样算法：</p>

<blockquote><p>该算法是针对从一个序列中随机抽取不重复的k个数，保证每个数被抽取到的概率为k/n这个问题而构建的。做法是：  -<br/>
首先构建一个可放k个元素的蓄水池，将序列的前k个元素放入蓄水池中。<br/>
然后从第k+1个元素开始，以k/n的概率来决定该元素是否被替换到池子中。
当遍历完所有元素之后，就可以得到随机挑选出的k个元素。复杂度为O(n).</p></blockquote>

<p>1.随机获取一个数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//统计num的个数</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">num</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>       <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>       <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>       <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//很显然id=0的概率为1/n，也就是每个num被选到的概率是1/n</span>
</span><span class='line'>            <span class="n">res</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>2.随机获取k个不重复数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">int</span> <span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="c1">//蓄水池</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span><span class="n">k</span> <span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//先放k个元素在蓄水池中</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>       <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>       <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//从第k+1个元素开始</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>       <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>       <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>       <span class="k">if</span><span class="p">(</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="p">)</span> <span class="c1">//这一步也很直观，num有k/n的概率被换到蓄水池中</span>
</span><span class='line'>            <span class="n">swap</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span><span class="c1">//把蓄水池中编号为id的数换成num</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//蓄水池中的k个数就是最终结果</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>证明每个数被取到的概率为k/n:</p>

<ol>
<li><p>对于第i个数(i&lt;k)，在前k步被选中的概率是1，
从第k+1步开始，i不被选中的概率为k/k+1,那么读到第n个数时，
第i个数(i&lt;k)被选中的概率 = 被选中的概率 * 以后每一步都不被换走的概率,即<br/>
1 * k/k+1 * k+1/k+2 <em>&#8230;</em>n-1/n = k/n</p></li>
<li><p>对于第j个数(j>=k)被选中的概率为：
在他出现时被选中的概率 * 在他出现以后不被换走的概率,即: <br/>
k/j * j /j+1 <em>。。。</em>n-1/n = k/n</p></li>
<li><p>综上得证。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++字符串分割]]></title>
    <link href="http://sleefd.github.com/blog/2013/03/24/str-split/"/>
    <updated>2013-03-24T15:42:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/03/24/str-split</id>
    <content type="html"><![CDATA[<p>文件解析，数据提取等都要用到字符串分割方法，笔试题也多有考到。</p>

<p>如果是用java语言编写的话，一般顺手就会敲出StringTokenizer，然后输入部分直接由Scanner类处理。</p>

<p>如将ip地址192.168.0.1解析成四段，可以如此写：</p>

<!-- more -->




<figure class='code'><figcaption><span>sample.java</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Sanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="s">&quot;in.txt&quot;</span><span class="o">);</span>
</span><span class='line'><span class="k">while</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">hasNextLine</span><span class="o">())</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
</span><span class='line'>    <span class="n">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">line</span> <span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="k">while</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">haxNext</span><span class="o">())</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">next</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果是用c++的话，有以下三种做法：</p>

<ol>
<li>使用cstring头文件中的strtok函数</li>
</ol>


<figure class='code'><figcaption><span>split1.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">delim</span><span class="p">[]</span> <span class="o">=</span> <span class="err">“</span><span class="p">,</span><span class="err">”</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">gets</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      <span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">delim</span> <span class="p">);</span>
</span><span class='line'>      <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>          <span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">delim</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>使用stdio.h中的sscanf</li>
</ol>


<figure class='code'><figcaption><span>split2.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&quot;%d.%d.%d&quot;</span> <span class="p">,</span><span class="o">&amp;</span><span class="n">a</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span> <span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>sscanf和sprintf是非常有用的函数，应该善用。<br/>
3.  使用strstr()或strchr()或substr()函数<br/>
用这些函数显然是通过寻找delim出现的位置，来分隔字符串。对delim是单个字符的就比较好写了，多个字符很麻烦吧。<br/>
还是以解析ip地址为例:</p>

<figure class='code'><figcaption><span>split3.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;192.168.1&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">part</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</span><span class='line'>  <span class="n">line</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span> <span class="c1">//字符串最后补一个delim，方便后面操作</span>
</span><span class='line'>  <span class="k">while</span><span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="s">&quot;.&quot;</span><span class="p">))</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>       <span class="n">len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span><span class="n">start</span><span class="p">;</span>
</span><span class='line'>       <span class="n">strncpy</span><span class="p">(</span><span class="n">part</span><span class="p">,</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>       <span class="n">part</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>  <span class="c1">//strncpy不会自动补&#39;\0&#39;</span>
</span><span class='line'>       <span class="n">start</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">part</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python入门(1)]]></title>
    <link href="http://sleefd.github.com/blog/2013/03/20/python-begin/"/>
    <updated>2013-03-20T13:15:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/03/20/python-begin</id>
    <content type="html"><![CDATA[<p>参考： http://blog.sina.com.cn/s/blog_a36b03a90101cyun.html</p>

<p>python是面向对象的，解释执行的，跨平台的，自己内存管理的脚本语言。</p>

<!-- more -->


<p><strong>弱类型语言</strong>：不需要申明变量的类型。<br/>
i,j = 3,4; #i=3,j=4</p>

<p><strong>两种变量类型</strong>：数值类型和引用类型。<br/>
除了数值之外，其他类型都是引用类型。比如list,元组等等。</p>

<h3>数值类型</h3>

<blockquote><p>long型可以是任意长度，数字常量后加l或L<br/>
复数类型: 3+4j or 3+4J</p></blockquote>

<h3>运算</h3>

<ul>
<li>四则元素： +、-、*、/、%</li>
<li>幂运算： **    &nbsp; &nbsp; 2 ** 3 = 8</li>
<li>逻辑运算： and or not</li>
<li>bool运算：is    ,   is not   ,   in ,    not in</li>
<li>位运算：&amp; | ~ ^</li>
</ul>


<h3>字符串</h3>

<ul>
<li><p>特点：<br/>
&#8221; or &#8220;&#8221; 括起来的字符序列  <br/>
r&#8217;\n&#8217; 或 R&#8217;\n&#8217;不转义字符<br/>
用&#8221;&#8220;&#8221;括起来，可包含换行字符串<br/>
与java一样字符串无法改变</p></li>
<li><p>操作：
乘法 表示重复字符串<br/>
分片:和matlab矩阵一样A[1:3]<br/>
长度: len(str)<br/>
遍历: for x in str:<br/>
格式化字符串：一种操作，like printf<br/>
(this is &#8220;%s&#8221;) %(str)</p></li>
<li><p>索引 从0开始，可以反向索引 从-1开始</p></li>
</ul>


<h3>内置复杂类型</h3>

<ul>
<li><p>列表 []括起来，元素可变，可保存任意对象，可动态增长<br/>
操作： append() /sort() index()  /reverse() / del list[1] <br/>
列表的分片，+，*操作产生新列表<br/>
  list = 1,2,3 #可省略括号</p></li>
<li><p>元组 （）括起来，非可变序列，可保存任意对象</p></li>
<li><p>字典
类似c++中的map</p>

<blockquote><p>{}括起来 {key:value, key2:value}<br/>
m.has_key()<br/>
m.keys() #返回所有键值组成的列表<br/>
m.values() #返回所有值组成的列表<br/>
len(m)<br/>
del m[k]</p></blockquote></li>
</ul>


<h3>比较</h3>

<p>== 比较字面值<br/>
is 比较引用</p>

<h3>标准输入输出：</h3>

<p>str = raw_input(&#8220;plz input something\n&#8221;);<br/>
print &#8220;hello,world&#8221;<br/>
文件读写操作： 和c相同<br/>
输入： input = open(&#8220;in.txt&#8221; , &#8220;r&#8221;);</p>

<pre><code>           s = input.read();
          s = input.read(N);
           readline();#返回string
           readlines() ; #返回list
</code></pre>

<p>输出: output = open(&#8220;out.txt&#8221; , &#8220;w&#8221;);</p>

<pre><code>     output.write(s);
     output.writelines(list);
</code></pre>

<p>output.close();</p>

<h3>流程控制</h3>

<p>if条件判断：</p>

<pre><code>if 条件：
    elif:
else:
</code></pre>

<p>while循环</p>

<pre><code>while 条件:
else:
</code></pre>

<p>for循环</p>

<pre><code>for x in str:
     do sth
else:
</code></pre>

<h3>函数定义</h3>

<p>def fun(params):
无需指明返回值，直接return 就行。<br/>
没有return时，返回none</p>

<p>python module 类似于java中的lib，里面定义一些可以被使用的函数<br/>
import module 或者from module import*</p>

<p><strong>doc</strong>文档字符串，每个对象都有这个属性，显示对象的说明文字，输出用&#8221;&#8220;&#8221;包含的内容<br/>
<strong>name</strong>模块属性：如果是调用的模块，则module.<strong>name</strong>输出模块名 如果是直接运行该模块则等于<strong>main</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用markdown写ppt]]></title>
    <link href="http://sleefd.github.com/blog/2013/03/07/markdown-ppt/"/>
    <updated>2013-03-07T20:40:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/03/07/markdown-ppt</id>
    <content type="html"><![CDATA[<h4>why markdown?</h4>

<p>最近一直用markdown写blog，深感markdown易于书写的特性。如果markdown能用于写ppt岂不是更好，再加上<a href="http://johnmacfarlane.net/pandoc/">pandoc</a>这个奇妙的工具，那么所有涉及到书写的工作基本上都可以由markdown完成了。</p>

<!-- more -->


<h4>principle</h4>

<p>偶然在Toplanguage上看到有人用<a href="https://github.com/bartaz/impress.js">impress.js</a>做的html格式的ppt，简洁而且可以直接丢在网上，感觉非常有趣。于是开始研究原理，发现其实很直观：强大的javascript+css3即可以实现很绚丽的ppt效果（其实前端开发也很有挑战性嘛~）。ppt书写可以直接由markdown,html,textile等语言完成，very nice~</p>

<p>花时间研究了一下，发现支持html ppt制作的template很多，比如deck.js,impress.js，reveal.js等等。最后找到了<a href="http://slideshow.rubyforge.org/">slideshow</a>这个ruby gem，易用而且支持上面提到的各种template，特此推荐。</p>

<h4>slideshow</h4>

<p>slideshow可以将markdown或textile等文件解析成ppt，所有的ppt页面都在一个html页中，因此你可以直接把这个html放在自己的网站上，供别人访问。</p>

<p>slideshow安装方法如下：<br/>
1. 安装ruby和ruby gems<br/>
2. gem install slideshow #安装slideshow gem</p>

<p>使用时直接 <code>slideshow test.md</code> 即可将test.md解析成test.html，双击打开就是一个ppt，方向键控制播放,F11全屏浏览，very simple.</p>

<p>与test.html同时生成的还有s6文件夹，包含s6模版文件；test.css，html样式表。<br/>
slideshow默认为s6模版。安装其他模版输入命令以deck.js为例：<br/>
&#8216;slideshow -f deck.js&#8217;</p>

<p>自己做了一个<a href="http://sleefd.github.com/denclue">demo</a>，关于密度聚类算法的ppt。<a href="http://sleefd.github.com/denclue/denclue.md">示例markdown</a>。</p>

<hr>


<p>slideshow参考:<a href="http://slideshow.rubyforge.org/">slideshow</a><br/>
推荐网站 <a href="www.rvl.io.">reveal</a>，支持在线ppt编辑，可直接生成一个在线浏览链接，非常方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译安装第三方lib]]></title>
    <link href="http://sleefd.github.com/blog/2013/02/27/use-third-library/"/>
    <updated>2013-02-27T22:08:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/02/27/use-third-library</id>
    <content type="html"><![CDATA[<h3>编译运行基本步骤</h3>

<p>./comfigure  #生成makefile，configure文件一般是Linux下可执行脚本<br/>
make  #编译<br/>
make install #安装文件<br/>
make uninstall #卸载文件</p>

<!--more-->


<h3>版本</h3>

<p>source distribution 源代码版本。第三方库或软件的源代码，需要自己编译才能使用。<br/>
源代码版本需要经过上述三个步骤才能执行。<br/>
binary distribution 二进制版本即可执行版本，已编译好的，在特点平台上可直接运行安装的。</p>

<h3>平台</h3>

<p>windows下使用源代码版本的软件或库，需要自己写makefile，然后make,make install.平时我们使用复杂的IDE如visual studio等，可以直接编译运行，不需要
自己写makefile，上述三个步骤已由IDE自己完成。</p>

<p>linux下源码包以压缩包的形式存在，需先解压，然后cd到所在目录，再输入上述三个命令即可。
注意阅读源码包中的readme和install文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程珠玑之幂函数]]></title>
    <link href="http://sleefd.github.com/blog/2013/01/27/pow/"/>
    <updated>2013-01-27T19:36:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/01/27/pow</id>
    <content type="html"><![CDATA[<p>问题来源：编程珠玑 ,column4, problem 9，修改log（n）内的递归求幂算法为迭代算法。这样才知道求幂有O(log(n))复杂度的算法，sigh。发现很多问题都可以用二分的思想来解决。</p>

<!-- more -->


<p>问题定义：求pow(x,n)，其中n为正整数。<br/>
解法一： 很直观的解法，每个人第一眼看到都会想到。将x乘以n次就ok嘛，一个for循环了事。时间复杂度O(n)。</p>

<ul>
<li>迭代求解</li>
</ul>


<figure class='code'><figcaption><span>pow1.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'> <span class="n">result</span> <span class="o">*=</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>递归求解</li>
</ul>


<figure class='code'><figcaption><span>pow2.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>解法二： pow(2 , 4)以解法一的话，需要做四次乘法，但是如果先计算2*2，再计算4*4,两次乘法ok，即log（n）次乘法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(n/2 == 0)
</span><span class='line'>      pow(x,n) = square(pow(x , n/2));
</span><span class='line'>    if(n%2 == 1)
</span><span class='line'>      pow(x,n) = x * pow(x,n-1)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>递归解法</li>
</ul>


<figure class='code'><figcaption><span>pow3.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>迭代求解</li>
</ul>


<figure class='code'><figcaption><span>pow4.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">*=</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>测试scaffolding:</p>

<figure class='code'><figcaption><span>test.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#define f pow</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="c1">// cout &lt;&lt; f(2,-1) &lt;&lt; endl; //源代码应该检查指数不为正整数的情况</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结： 二分的方法在很多地方都能使用，以后遇到算法优化，首先考虑二分。<br/>
将第二种解法的递归形式改为迭代形式我想了好久。仔细想想，递归是自顶向下的求解方法，
而迭代是自底向上的求解方法，然后枚举出所有的可能情况，就可以很好的写出递归或迭代形式的算法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[四时之景不同，而乐亦无穷也]]></title>
    <link href="http://sleefd.github.com/blog/2013/01/12/donghuxing/"/>
    <updated>2013-01-12T21:37:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/01/12/donghuxing</id>
    <content type="html"><![CDATA[<p>和喵环东湖一周，大概2个半小时吧，挺快的，比平时快多了。<br/>
今天东湖雾很大，一眼看不到太远，虽没有秋天的静谧，没有秋天的金棕色红色，但是薄雾笼罩下的东湖确实别有风味。环湖路上的汽车依然很多，公汽依然不客气，随意的就把我们小折叠挤到路边边。</p>

<!-- more -->


<p>今天天气算暖和了，因此骑车的人很多，折叠山地都有，普通车也有。虽有风，我依然穿了一件抓绒衣，一件马甲，魔术头巾当口罩，轻装出行，很快意。以不快不慢的速度骑行，然后不时能瞟一下湖两边的风景，人生真美好~<br/>
依然是从工学部外的那个桥骑入东湖。没走多远，就看到一对老夫妻在路边很小块的田地里耕田。老奶奶是搬个板凳坐着的，老爷爷站着翻土，画面很和谐。我依然认为乐享天伦之乐是人世间最幸福的事情。<br/>
继续往前走到梅园，正举行东湖2013年梅花节。梅园梅花的品种很多。记得同yuqi翻墙进梅园的那时，梅花还未盛开，但是梅园很静。现在梅花已开，看墙壁上挂的各种梅花图片，还是挺想进去的，但是带着车有诸多不便，于是继续向前。<br/>
然后到磨山风景区入口，有一个自动租借书籍的机器，刷武汉通就可以了，顿时觉得武汉通真好用，不仅能刷地铁还能借杂志，如果以后绕东湖乏了，还能借一两本书，在常去的那小片总是有太阳照射的草地上躺着看看，其实很美。<br/>
喵说想绕整个东湖，我也就没按平时走一部分路然后往回骑，继续向东湖海洋生态馆和听涛景区进发。竟然碰到一个背包徒步游东湖的人，同好呀。改明儿有时间我也来个徒步环东湖，在武汉也只独自一人徒步从信息学部大门一直走到长江大桥过，和小白一起从龟山走到过江滩。<br/>
过了听涛景区之后竟然有点不认识路了，只记得要经过省博一直往前走，于是在路上抓了个阿姨问问。阿姨说也刚到这儿不清楚，然后我们说去武大，她就清楚了，很耐心的为我们指了路，走的时候还不时回头嘱咐我们，所以说这个世界好人是很多的~<br/>
接着遇到一个地下通道不知道要不要下去，又问一阿姨，阿姨的自行车貌似坏了，要推着走，但是还是让我们直接从通道骑下去，不需要跟她一样推，嘿嘿。顺利骑下去然后拐弯。
绕回来的时候又到工学部旁边那条东湖路，竟然看到一个人骑着山地后面带着一个箱子，箱子里面放着他的小狗，真可爱。狗头还伸出箱子外往外望，太有爱了，哈哈。<br/>
总之，骑行过程很舒心，回来之后腰酸腿疼，各种累，某喵同学还吵着要去按摩~哈哈
心在路上，从未停止。</p>

<hr/>


<p>能走不同的路，看不同的风景，有三五好友，还有什么值得追求？<br/>
有一颗自由的心，且能时刻保持着对万物的兴趣与怜悯，还有什么值得拥有？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress博客搭建中问题汇总及解决方法]]></title>
    <link href="http://sleefd.github.com/blog/2012/12/28/build-problems/"/>
    <updated>2012-12-28T20:53:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2012/12/28/build-problems</id>
    <content type="html"><![CDATA[<ol>
<li><p>bundle install时，ffi包装不上：</p>

<p>将gemfile.lock文件中所有涉及到ffi版本号的地方都改为ffi (~>1.1.1)<a href="http://michael-roshen.iteye.com/blog/1613151">【参考】</a><!--more--></p></li>
<li><p>bundle install时，安装某个包提示<code>&gt; ERROR: Failed to build gem native extension.</code></p>

<ul>
<li><a href="http://rubyinstaller.org/downloads/">安装Devkit</a></li>
<li>配置环境变量path为devkit下的bin目录</li>
<li><p>执行代码</p>

<p><code>
ruby dk.rb init<br/>
ruby dk.rb install
</code></p></li>
</ul>
</li>
<li><p>rake generate失败</p>

<ul>
<li>检查_config.yml，注意每个冒号后面都有空格</li>
<li>大多数原因是中文解析问题。<br/>
首先所有的markdown文件应为UTF-8格式，然后修改
你ruby安装目录下的convertible.rb：<br/>
<code>
self.content = File.read(File.join(base, name))改为<br/>
self.content = File.read(File.join(base, name), :encoding => "UTF-8")
</code></li>
</ul>
</li>
<li><p>使用模版的方法：<br/>
RTFM:一定要看模版说明<br/>
通过修改_config.yml中的相关变量来基于模版个性化自己的博客。</p></li>
<li><p>使用<code>&lt;!-- more --&gt;</code>来显示post中的部分内容。该标签后的所有内容将不被显示。</p></li>
<li><p>配置disqus的方法：</p>

<ul>
<li>注册disqus id，配置与你的站点关联，取一个站点shortname，记住它，很重要。</li>
<li>设置_config.yml中disqus部分：<br/>
disqus_short_name: 站点shortname<br/>
disqus_show_comment_count: true</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mex调用c代码备忘]]></title>
    <link href="http://sleefd.github.com/blog/2012/12/28/mex/"/>
    <updated>2012-12-28T16:36:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2012/12/28/mex</id>
    <content type="html"><![CDATA[<ul>
<li>目的：在matlab中调用c函数，加快代码执行速度或实现c代码复用。</li>
<li>媒介：mex file
  有约定俗成的格式，c源文件必须包括头文件 &#8220;mex.h&#8221;, 函数 mexFunction为入口函数.
  当然也可以使用其他符合c语法的函数，头文件。</li>
<li>关键： 各种数据类型在matlab和c之间的转换，传递。</li>
</ul>


<!-- more -->


<ul>
<li>mexFunction的签名为
<code>
  void mexFunction( int nlhs,
   mxArray <em>plhs[],
   int nrhs,
   const mxArray </em>prhs[])
</code>
参数解释：
  nlhs: 输出个数
  nrhs: 输入参数的个数
  plhs: 指向输出的指针数组
  prhs: 指向输入的常指针数组</li>
<li>数据类型：
  matlab传递给c的数据类型都是mxArray类型,matlab的所有数据类型内部都以mxArray的形式存储。(可以猜想mxArray是一个结构体类型。</li>
<li>基本操作：mx/mex函数

<pre><code>   1. *mx开头*的函数为对数据进行操作的函数.
      记住：有Get操作，就有对应的set操作，而且由于操作大多针对指向数据的指针，所以
      set操作可能会改变workspace中的变量。
   2. *mex开头*的函数为与workspace交互的函数，如输出error message ,warning message , printf data等。
</code></pre></li>
</ul>


<h4>代码示例</h4>

<ul>
<li>c从matlab获得数据
  获取matrix:

<pre><code>  double *p = mxGetPr(prhs[0]) ;//得到指向第一个数据参数的指针。 注意：所有包含数值的参数都是double类型。
  只要参数是matrix(m*n)类型，都可以通过mxGetPr得到指向数据的指针，数据以从上到下从左到右的形式存储。（也就是线性的~
</code></pre>

  获取维数：

<pre><code>  `mexGetM(mxarray)/mexGetN(mxarray)： 得到mxArray的row &amp;&amp; column 数`
</code></pre>

<p>  获取cell数据类型：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(int index = 0 ; index &lt; size  ; ++index)
</span><span class='line'>      {
</span><span class='line'>          mxArray * p = mxGetCell(prhs[0] , index); //得到index处的mexArray
</span><span class='line'>          double *elem = mxGetPr(p);
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<pre><code>直接获取data（数值
</code></pre>

<p>`       double *data;</p>

<pre><code>    data = mxGetData(prhs[0]);
    //mxSetData(p1hs[0] , data);
    `
</code></pre>

<ul>
<li>c返回数据给matlab

<pre><code>workspace输出：mexPrintf,类似c printf函数。  mexPrintf("%d\n" , number);
               mexErrMsgTxt,打印error消息。 mexErrMsgTxt("This is an error message.");
               mexEvalString,在workspace中调用string指定的命令。 mexEvalString("plot([1:5])"); //plot命令会被执行
</code></pre>

   想要返回数据给matlab，首先要分配空间给输出数据，这样它才能存在于当前的workspace中。

<pre><code>  分配空间的方法 1 plhs[0] = mxCreateDoubleMatrix(m,n,mxReal);
                  double *data = mxGetPr(plhs[0]); //and then you can assign values to data.
                 2 利用mxMalloc (用法类似c malloc
                  double *data = mxMalloc(sizeof(double) * num);
                      ... //assign values
                  mxSetPr(prhs , data);
</code></pre></li>
<li>动态内存分配:使用mxMalloc/mxFree mxCalloc/mxFree

<pre><code>       虽然c malloc和free也可以使用，但是会导致不可预知的错误，所以谨记使用mex functions.
</code></pre></li>
</ul>


<p>配置mex file编译环境在matlab中：</p>

<pre><code>直接在命令行下输入 mex -setup 选择合适的编译器就ok了。
</code></pre>

<p>调试：可在VS中采用附加进程调试</p>

<p>有价值的资料：</p>

<pre><code>1. apiext.pdf //matlab external interface 
2. mexguide.pdf 
</code></pre>
]]></content>
  </entry>
  
</feed>
