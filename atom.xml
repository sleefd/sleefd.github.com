<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bright Shine]]></title>
  <link href="http://sleefd.github.com/atom.xml" rel="self"/>
  <link href="http://sleefd.github.com/"/>
  <updated>2014-01-20T21:46:12+08:00</updated>
  <id>http://sleefd.github.com/</id>
  <author>
    <name><![CDATA[slee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[适配器模式]]></title>
    <link href="http://sleefd.github.com/blog/2014/01/20/adapter-model/"/>
    <updated>2014-01-20T20:31:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2014/01/20/adapter-model</id>
    <content type="html"><![CDATA[<h4>什么是适配器</h4>

<p>以常见的电源适配器为例：比如手机的充电器
，笔记本电脑的电源。日常供电电压是220v,手机充电器将日常电压转
化成手机能用的电压（5v左右）,手机才能冲进电。
香港的笔记本电压是110v,而大陆的电压是220v,如果要让香港的笔记本电脑能在大陆充电要怎么做呢？
需要一个适配器将220v的电压输入转为110v输出，如此笔记本电脑才能充电。</p>

<!-- more -->


<p>因此适配器是一个转换器，将一种输入转化成另一种输出，将一个接口转化成另一个接口，
以较小的代价实现功能的复用。</p>

<h4>适配器模式及好处</h4>

<p>适配器模式是常见的设计模式之一。通过将现有接口转化成另一个需要的接口，
可以复用第三方组件或现有功能模块，避免重复功能的开发。</p>

<h4>适配器模式的实现方法</h4>

<p>使用适配器模式的目的是提供一个可用的接口。<br/>
因此需要一个接口类，定义我们需要的接口；<br/>
接着需要一个类实现这个接口，提供必须功能。这个类通常被称为Adapter。<br/>
当然还有一个类已经提供了我们所需功能的部分实现，需要被复用，称为Adaptee.<br/>
关键是Adapter如何复用Adaptee的功能。方法有两种：</p>

<ul>
<li>Adapter继承Adaptee</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Functions</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">Adaptee</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">(</span><span class="kt">int</span> <span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="c1">//do something....</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">Adapter</span> <span class="kd">extends</span> <span class="n">Adaptee</span> <span class="kd">implements</span> <span class="n">Functions</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Adapter引用Adaptee类，包含一个Adaptee对象成员</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Adapter</span> <span class="kd">implements</span> <span class="n">functions</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Adaptee</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">obj</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradle一瞥]]></title>
    <link href="http://sleefd.github.com/blog/2014/01/11/gradle/"/>
    <updated>2014-01-11T22:20:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2014/01/11/gradle</id>
    <content type="html"><![CDATA[<p>gradle是一个自动化够建工具，用groovy语言编写。
通过gradle脚本可以一次性完成很多任务，比如编译，测试， 打jar包，多项目管理，依赖管理等等。</p>

<!--more-->


<h3>task</h3>

<p>task是gradle脚本定义的，一个项目可以执行的任务。</p>

<p>gradle tasks 查看所有可以执行的任务</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="c1">//定义task</span>
</span><span class='line'><span class="n">task</span> <span class="n">hello</span><span class="o">&lt;&lt;{</span>
</span><span class='line'>    <span class="n">println</span> <span class="s2">&quot;hello world&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>gradle hello //运行Hello task</p>

<h3>plugin</h3>

<p>plugin是gradle预先设置好的一些task，直接使用plugin就不需要自己code task。
比如java plugin，可以帮忙完成java代码的编译，测试，打jar包。
idea plugin，可以把项目打包成idea工程。<br/>
apply plugin后，gradle tasks查看可使用的task。</p>

<p><strong>使用方法</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="c1">//gradle.build</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;java&quot;</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;idea&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>常见的plugin有:</p>

<ul>
<li>java: 提供java源代码编译，测试，运行，打包等功能</li>
<li>idea: 构建idea工程</li>
<li>eclipse: 构建eclipse工程</li>
<li>jetty: 添加jetty服务器支持</li>
<li>war: web project打包成war包</li>
</ul>


<h3>dependency management</h3>

<p>很多时候项目编译要依赖第三方库，比如测试要使用junit,画图表要用Jfreechart，spring框架需要spring的库等。
gradle可以管理这些依赖，自动下载需要的库。</p>

<p>repositories定义外部依赖的来源。
dependencies定义需要的依赖。</p>

<p>声明外部依赖</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="c1">//build.gradle</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;java&quot;</span>
</span><span class='line'><span class="n">repositories</span><span class="o">{</span>
</span><span class='line'>    <span class="n">mavenCentral</span><span class="o">()</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span><span class="o">{</span>
</span><span class='line'><span class="n">compile</span> <span class="s2">&quot;com.google.guava:guava:15.0&quot;</span>
</span><span class='line'><span class="n">testCompile</span> <span class="s2">&quot;junit:junit:4.8.2&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>gradle wrapper</h3>

<p>wrapper是一个task.当项目成员木有安装gradle时，通过gradle wrapper可以自动下载安装gradle.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="c1">//build.gradle</span>
</span><span class='line'><span class="n">task</span> <span class="nf">wrapper</span><span class="o">(</span><span class="nl">type:</span><span class="n">Wrapper</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">gradleVersion</span> <span class="o">=</span> <span class="s2">&quot;1.4&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>example</h3>

<ul>
<li><p>java项目</p>

<ol>
<li><p>创建项目目录,java plugin有约定的项目目录格式:</p>

<p>   src<br/>
   &#8212;-main&#8212;java<br/>
   &#8212;-test&#8212;java<br/>
   mkdir src\main\java<br/>
   mkdir src\main\test</p></li>
<li><p>build.gradle</p></li>
</ol>
</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;java&quot;</span>
</span><span class='line'><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;idea&quot;</span>
</span><span class='line'><span class="n">repositories</span><span class="o">{</span>
</span><span class='line'>    <span class="n">mavenCentral</span><span class="o">()</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">dependencies</span><span class="o">{</span>
</span><span class='line'>    <span class="n">testCompile</span> <span class="s2">&quot;junit:junit:4.8.2&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>3. gradle idea  
  创建idea项目
</code></pre>

<ul>
<li><p>spring项目</p>

<ol>
<li><p>创建项目目录</p>

<p>  src<br/>
  &#8212;main&#8212;java<br/>
  &#8212;webapp&#8212;WEB-INF&#8212;pages<br/>
  &#8212;test&#8212;java</p></li>
<li><p>build.gradle</p></li>
</ol>
</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='groovy'><span class='line'>       <span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;java&#39;</span>
</span><span class='line'>      <span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;idea&#39;</span>
</span><span class='line'>      <span class="n">repositories</span><span class="o">{</span>
</span><span class='line'>      <span class="n">mavenCentral</span><span class="o">()</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="n">dependencies</span><span class="o">{</span>
</span><span class='line'>      <span class="n">compile</span> <span class="s2">&quot;org.springframework:spring-webmvc:3.2.0.RELEASE&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">testCompile</span> <span class="s2">&quot;junit:junit:4.8.2&quot;</span>
</span><span class='line'>      <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>3. gradle idea
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[思维的偏执]]></title>
    <link href="http://sleefd.github.com/blog/2013/05/08/mind-prejudice/"/>
    <updated>2013-05-08T12:31:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/05/08/mind-prejudice</id>
    <content type="html"><![CDATA[<h5>由求m*n网格中矩形的总个数想到的</h5>

<p>这个问题出自微软今年（2013）实习生的笔试题。原题是确定3*4网格中矩形的总个数，答案从5个选项中选一个。一般化之后也就是m*n网格中矩形的总个数是多少。</p>

<p>以下先叙述下我对这个问题的思维求解过程：</p>

<p>看到这个题第一直觉是找规律，应该有一个公式可以直接计算出结果。而找规律的一般做法有两种：一是把原问题分解成几个小问题，求解每个小问题，然后综合得出结果;二是研究几个简单特例，然后从特例中总结出一般规律。这两种做法在考场中我都采用了。</p>

<!--more-->


<ol>
<li><p>矩形可以由1个网格组成，2个网格组成，3个网格组成。。 那么矩形的总个数应该是所有这些可能性之和。</p></li>
<li><p>1个网格组成: m*n</p></li>
<li>2个网格组成：(n-2+1)*m + (m-2+1)*n</li>
<li>3个网格组成：(n-3+1)*m + (m-3+1)*n</li>
<li>4个网格组成：n=4&amp;&amp;m&lt;4 (1*4网格组成的矩形个数)+ (2*2网格组成的矩形个数)<br/>
第一部分个数为：(n-4+1)*m, 那么第二部分是多少呢？我颤抖了一下，这很难确定啊。(n-2+1)*(m-2+1)。在仔细考虑下难道对于每种网格组成我要考虑它的所有构成情况，比如4可以分解为1*4,2*2，那我就要考虑这两种情况罗，当m、n变大时，需要考虑的情况更多。。。</li>
<li>5个网格组成: 显然不行嘛。。。</li>
<li>6个网格组成： 可以嘛。。
。。。</li>
</ol>


<p>颤抖了一下，这种做法我岂不是既要确定所有的网格组成情况，还要确定每个情况下的总矩形数，工程相当大啊。。。 于是默默pass掉这种做法。</p>

<p>2.由特例到一般。1*1网格中矩形的总个数是1，2*2网格矩形总个数是9个，2*3网格中矩形的总个数是18个，我肉眼看去没有什么规律啊..又pass掉。</p>

<p>由于是选择题，在笔试考场的我，最后直接选择了最笨却最有效的方法，直接数矩形的个数。3*4网格，多小啊，总共才12个小矩形。</p>

<ul>
<li>1个网格组成: 3*4 = 12</li>
<li>2个网格组成： 3*3 + 2*4 = 17</li>
<li>3个网格组成： 2 * 3 + 1 * 4 = 10</li>
<li>4个网格组成: 1 * 3  + 3 * 2  = 9</li>
<li>6个网格组成：2 * 2 + 3 = 7</li>
<li>8个网格组成：2</li>
<li>9个网格组成： 2</li>
<li>12个网格组成： 1</li>
</ul>


<p>总矩形个数为：12 + 17 + 10 + 9 + 7 + 2 + 2 + 1 = 60</p>

<p>正确答案就是60了，可是我在笔试的时候算出来的确是58，为什么呢？我没有算9个网格组成矩形的情况，算漏了！why?在整个计算过程中我学习到偶数网格才能组成矩形，于是9个网格直接被我pass掉了。</p>

<p><strong>学习过程竟然中出现了偏差，那人的学习是可信的嘛？如何才能保证思维的完备性呢？在高压的情况下，如何保证能面面俱到，考虑每个细节，而没有疏漏？</strong></p>

<hr />

<p>微软笔试之后，我一直在找规律，但是每次的出发点都是方法一，算1个网格，再算2个网格，最后总是会卡在同一个地方。直到今天中午突然想到了新的解法。<strong>为什么我每次思考都是从方法一开始呢？</strong></p>

<p>矩形可以换一种描述方式,用x*y描述矩形,也就是网格形式描述矩形。
那么很显然x的取值在[1,m],y的取值在[1,n]，总共考虑m*n种网格形式就ok了。</p>

<p>对于某个x，共有m-x+1个不同的位置，y的取值范围为[1,n]。  <br/>
对于y的某一个值<em>y,有n-</em>y+1种不同的可能。<br/>
那么对于某个x:<br/>
所有的可能数：(m-x+1)*[(n-1+1) + (n-2+1) +&#8230;+(n-n+1)]= (m-x+1)*n*(n+1)/2
而x的取值范围是[1,m],因此最终结果是:<br/>
ans = m*(m+1)/2*n*(n+1)/2</p>

<hr />

<p>上面是我个人的思维过程。<br/>
可以发现，新的思考角度或切入点，会带来意想不到的效果。</p>

<p>我们倾向于执着的从同一入口考虑问题，而不愿意改变思维方式或角度，过分偏执的相信自己的第一直觉。因为第一直觉是我们的舒适区，谁都愿意呆在自己的舒适区里，right?因为舒适区里，我们曾经有过成功的经历。如何打破自己的舒适区呢？</p>

<p>很多我们认为理所当然的解法或者第一直觉往往很难改变，而这恰恰是我们陷入思维误区的开始。一个错误的方向意味着永远找不到正确的答案。所以如何多角度的考虑问题呢？</p>

<p>p.s 由于每个人的经历、经验、思考方式不同，或许你会第一眼就找到上述问题的正确入口点，但是难保你不会有和我一样陷入思维怪圈的经历。在陷入思维的怪圈之后，如何突破呢？</p>

<p>这次思考让我意识到，很多你认为有挑战性难解的问题，只要换一个角度说不定就能打开一个新天地，找到有效的解法。所以有顿悟这一说法嘛。</p>

<p>最近想多看一下思维和心理学方面的书籍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xml笔记]]></title>
    <link href="http://sleefd.github.com/blog/2013/05/08/xml-note/"/>
    <updated>2013-05-08T12:24:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/05/08/xml-note</id>
    <content type="html"><![CDATA[<p>大摩的IKM online test考到了xml，因此在w3school上学习了下xml.</p>

<p>xml: extensible markup language，可扩展标记语言</p>

<p>用来传输和存储结构化的数据，而html是负责表现数据。xml旨在传输信息，而html旨在显示信息。</p>

<p>xml的特点：纯文本，自解释性的，简化数据共享、传输</p>

<!-- more -->


<p>用在很多地方，比如web service, RSS等，很多应用程序使用xml交换数据。</p>

<p><strong>xml语法：</strong></p>

<ul>
<li><p>xml声明: <code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</code></p></li>
<li><p>xml的标签组成了树形结构</p>

<p>  必须有一个根元素。<br/>
元素之中可以有子元素，构成树形层次关系。<br/>
  元素之间的内容为文本节点。
  每个标签必须是闭合的。有<code>&lt;ele&gt;</code>,必有<code>&lt;/ele&gt;</code> 。 <br/>
  标签可以带有属性，属性必须用引号括起来，单引号双引号都可以，如<code>&lt;from date='1990-2-3'&gt;Jenny&lt;/from&gt;</code><br/>
  有些属性应该是数据内容，应该用元素标签表示，不应该使用属性表示 <code>&lt;date&gt;1990-2-3&lt;/date&gt; &lt;from&gt;Jenny&lt;/from&gt;</code></p></li>
<li><p>元素名称的命名要求：</p>

<p>  不能以xml（不区分大小写）开始<br/>
  不能以数字和标点符号开始<br/>
  名称之间不能有空格，<code>&lt;first name&gt;</code>错误的命名。</p></li>
<li><p>xml元素必须正确的嵌套。</p></li>
<li><p>形式良好的xml文档满足上面所有的语法要求。</p></li>
</ul>


<p><strong>xml验证：</strong></p>

<p>由xml文档规则直接检验xml文档的正确性。规则由DTD(document type definition)和xml schema定义。两者都定义了xml需满足的要求，schema使用更多。</p>

<p><strong>xml显示: 为xml文档添加显示效果</strong></p>

<p>使用css和XSLT(extensible stylesheet language transformations)显示文档。
语法 <code>&lt;?xml-stylesheet type="text/css" href="cd_catalog.css"?&gt;</code> 或 <code>&lt;?xml-stylesheet type="text/xsl" href="simple.xsl"?&gt;</code>
将样式表或XSLT链接到该xml文档。</p>

<p><strong>xml解析：</strong></p>

<p>首先要获取xml文档对象，然后通过xml DOM获取对象的元素文本内容结合html DOM在html中显示出来。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>  <span class="nx">xmlhttp</span><span class="o">=</span><span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
</span><span class='line'><span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span><span class="s2">&quot;cd_catalog.xml&quot;</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span>
</span><span class='line'><span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>
</span><span class='line'><span class="nx">xmlDoc</span><span class="o">=</span><span class="nx">xmlhttp</span><span class="p">.</span><span class="nx">responseXML</span><span class="p">;</span><span class="c1">//xml文档对象</span>
</span><span class='line'><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;book&quot;</span><span class="p">).</span><span class="nx">innerhtml</span> <span class="o">=</span> <span class="nx">xmlDoc</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;book&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">nodeValue</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong> xml基础测试: </strong></p>

<p>直接做xml测验就ok了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微软2013实习笔试查漏补缺]]></title>
    <link href="http://sleefd.github.com/blog/2013/05/06/ms-intern-write-test/"/>
    <updated>2013-05-06T21:37:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/05/06/ms-intern-write-test</id>
    <content type="html"><![CDATA[<p>微软2013暑期实习笔试题部分题目分析。
比较欣慰的是俺通过了这次笔试，哈哈= =</p>

<ul>
<li><em>cdecl 和 </em>stdcall的区别</li>
</ul>


<!-- more -->


<p>原题是c++哪种函数调用方式支持变长参数调用。<br/>
第一直觉是在_cdecl和_stdcall中选，其中一个是由主调函数压栈和弹栈，一个由被调用函数自己压栈和弹栈，但是忘记了谁对应谁。<br/>
然后又联想到printf函数，这个函数是支持变长参数的，推理一下就是默认的调用方式支持变长参数，可惜忘了两者间哪个是默认的调用方式，sigh.</p>

<ol>
<li><p>_stdcall是Pascal程序的缺省调用方式，通常用于Win32 Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上&#8221;@&#8221;和参数的字节数。 int f(void *p) &#8211;>> _f@4(在外部汇编语言里可以用这个名字引用这个函数)</p></li>
<li><p>_cdecl是C调用约定（The C default calling convention），按从右至左的顺序压参数入栈，由调用者把参数弹出栈,。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数 vararg的函数(如printf)只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。 <em>cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用</em>stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀。</p></li>
<li><p>m*n网格中矩形的总个数</p>

<p>  公式是:<code>sum = m*(m+1)/2*n*(n+1)/2</code>，分析见<a href="">思维的偏见</a></p></li>
<li><p>MVC模式理解</p>

<p>  这种概念题用英文表达后感觉很难选对。<br/>
  MVC是一种软件架构。MVC的核心思想是代码重用和功能分离。<br/>
  model:负责处理数据和数据相关的请求。<br/>
  view:负责显示数据。<br/>
  controller:负责业务逻辑，处理用户的请求，把model层的数据在view层显示出来。</p></li>
<li><p>链表和数组的区别</p>

<p>  A. 当两者都有序时，搜索时间复杂度不同<br/>
B. 动态增加和删除元素<br/>
C. 随即访问效率<br/>
D. 数据存储类型<br/>
选A,B,C,D.<br/>
A:数组二分搜索比链表快，因为链表不支持O(1)的随机访问。<br/>
B:链表增添删除元素容易。<br/>
C:数组支持下标随机访问。<br/>
D:链表的数据存储类型必须为复合类型，数组既可以支持复合类型也可以支持简单类型。</p></li>
<li><p>const使用</p>

<p>  定义整型常量：<br/>
  const int a = 4;<br/>
  int const a = 4;<br/>
  定义指针常量：<br/>
  const int <em>p = &a;<br/>
  int const </em>p = &a; <br/>
  定义常指针:<br/>
  int *const p = &a;</p></li>
<li><p>输出题</p></li>
</ol>


<p>当时没意识到，这是一个指针类型转换问题。从子类指针转为父类指针，数据宽度变小，指针每次移动的大小也变小。</p>

<p>A是父类，有数据long a;B是A的子类，增加数据long b;</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">setA</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">data</span> <span class="p">,</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">data</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">B</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">//输出是什么？</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="c1">//输出22221111</span>
</span></code></pre></td></tr></table></div></figure>


<p>分析：从B类型的指针转为A类型的指针，指针指向的数据从8个字节变成了4个字节，则每次setA改变 data[i*4]这个位置的值，因此最终结果是22221111</p>

<ul>
<li><p>除法和右移的区别</p>

<p>  题目：F和G、X是32位有符号整数,F = X/2,G = X>>1,最后发现F!=G，这意味着：<br/>
  A. 有编译错误<br/>
  B. X是奇数<br/>
C. X是负数<br/>
D. F-G = 1<br/>
E. G-F = 1</p>

<p>  答案 B,C,D <br/>
分析：
首先X是负数，正数除以2和右移没有区别。
X是负数，右移是在前面补1.随便举例一看，X是奇数且F-G = 1。如果X是负偶数，F=G.</p></li>
<li><p>天平称量问题</p>

<p>  题目：N个球中有一个球比其他球轻，问若称量三次能找到这个次品球，可能的N的取值。<br/>
分析：这个题目在刘未鹏的《暗示间》里面“快排为什么那样快？”这一章有讲解。天平可以处在三种状态:平衡、左轻、右轻。每一次称量，排除三分之一的可能性。称量m次最多可以解决m<sup>3个球的情况。</sup></p></li>
</ul>


<hr />

<p>细细回味了下微软的题，感觉每一题都很有意思。
另外意识到自己的思考能力很弱，思考全面性急需提高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易游戏QA工程师实习生求职经历]]></title>
    <link href="http://sleefd.github.com/blog/2013/04/13/netease-interview/"/>
    <updated>2013-04-13T01:16:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/04/13/netease-interview</id>
    <content type="html"><![CDATA[<p>处女面献给了网易游戏。</p>

<p>我投的是网易游戏qa工程师，先在网上投简历，然后经历了电话面试，当面两轮面试一共三轮面试。比较顺利的拿到了offer.</p>

<!--more-->


<h4>一面: hr电话面试</h4>

<p>简历通过筛选之后，接到了网易广州打来的话，约hr电话面试时间，定在第二天的晚上7点到7点半之间。当时觉得好奇怪，hr面试不是应该放在整个流程的最后面的嘛,但是网易偏偏是一面。嗯，然后在网上找了下面经什么的，发现没有。于是怀着忐忑的心情继续看自己的书，忐忑啊忐忑，然后到了第二天晚上。</p>

<p>晚上7点多的时候接到了hr的来电。首先让我做自我介绍，然后告诉我说以下对她的问题的回答都通过举实例说明。话说我从来没有在电话里面巴拉过这么多话，囧。提到的问题如下:</p>

<ul>
<li>在大学做过的最有成就感的一件事情</li>
<li>你曾经和同伴发生过争吵吗，怎么解决的</li>
<li>举例说明你是如何树立目标并达成的</li>
<li>为什么选择网易，选择这个职位</li>
</ul>


<p>能记得的就这么几个问题，整个时长25分钟左右，大部分时间都是自己在说，hr在听。回答完之后hr告知清明之后会再通知，没有就是没通过电面。</p>

<p>说实话挂电话之后，挺怀疑自己的，感觉回答的不是很清楚，表达能力有限啊。。。</p>

<h4>二面:专业一面（4.10）</h4>

<p>清明之后，接到了网易的电话约面试时间，话说网易工作人员打了三次电话来更改时间，额。最后确定在4.10号下午4点。</p>

<p>下午四点在hust 1号楼等候面试，去了之后才知道1号楼以及8号楼是宾馆，面试官都住在里面。我们全部在会议室里等候，由工作人员负责通知面试地点。提前到了40多分钟，等的很是煎熬。哎。。等的过程中遇到一个同校同院的家伙，超级不喜欢他，不解释。</p>

<p>8号楼701，三个面试官等待着我，2男一女。
刚到就被招呼到沙发上坐下，然后我递出了三份简历。我想说网易的面试官都very nice。整个过程非常轻松。</p>

<p>一个面试官负责问技术问题，包括简历中的项目。</p>

<ul>
<li>面向对象的概念，然后让我对现场的场景建模</li>
<li>c与c++的区别，因为我写了熟悉c++.</li>
<li>tcp/ip协议栈的组成，为什么要分层，我的项目涉及到这个。</li>
<li>复杂网络社区发现是干什么，我的科研经历</li>
<li>推荐系统的实现，多示例学习，我的科研经历</li>
</ul>


<p>女面试官问测试相关的东西:
折叠自行车怎么测试，我写到了喜欢骑行，囧。涉及到压力测试，性能测试啊等等。</p>

<p>还有一个面试官很funny，飙了句日文，我竟然说是粤语，尴尬，哄堂大笑，感觉我就是去搞笑的，哎。他问了两个问题，数理逻辑方面的吧，我都没回答出来，但是有分析。</p>

<ul>
<li><p>两个素数中间的一个数能被6整除嘛？<br/>
抽象一下就是a,a+1,a+2，a和a+2是素数，a+1能被6整除嘛？<br/>
话说这个题不严谨，a应该大于3，否则3，4，5，4明显不能被6整除嘛。<br/>
如果a=3，不能。<br/>
如果a!=3,能。
首先，两个素数中间的数一定是偶数能被2整除。<br/>
下面只需考虑中间数能否被3整除。<br/>
3k-1,3k,3k+1，恰好能表示所有>=2的整数，right?<br/>
素数只能是3k-1,3k+1,中间数一定是3k，能被3整除，故能被6整除。</p></li>
<li><p>这到题你可能在weibo或智力书上看了好几次，反正我是被误导了。<br/>
3个人去住店，每个人出10块钱。老板找他们5块，让自己的小孩去还给他们，然后小孩觉得5块不好分，于是拿走了2块，话说为什么少了一块呢？
三人一共出了27块，被拿走了2块，相当于出了28块啊，那一块哪里去了，这样想就被误导了。。
三个人出了9*3=27块，老板收益25+2=27，ok了。</p></li>
<li><p>桌上一瓶矿泉水，问有什么作用。
武器啊，卖钱啊，装水啊，储物啊，漏斗啊，装饰，插花啊等等。</p></li>
</ul>


<p>总之，整个过程很欢乐- -很嘻哈- -<br/>
晚上接到了第二天的专业二面通知。</p>

<h4>三面（终面）:专业二面（4.11）</h4>

<p>说是专业二面其实没问什么专业的东西，昨天晚上白忐忑了。9:10分的面试，我起了一个大早，因为从WHU赶到HUST要坐40分钟左右的公汽，到hust之后还得坐校车，话说为找实习跑了好多次HUST啊，从来没有这么折腾过。</p>

<p>也是3个面试官，整个过程就是随意的聊聊天。
问了下你想去什么样的公司，你希望你的同事是什么样的，个人的兴趣爱好，你希望从工作中获得什么，很随意，面试官都很nice。</p>

<p>事后回忆自己的回答各种2不解释。我这个2B面完之后又嘻嘻哈哈的回到了学校。（据说最后这一面还有人被刷的。。。我竟然没被刷- -</p>

<p>当天下午就接到网易的通知说过了终面，高兴地从被子里面爬起来奔向hust拿到了offer通知书。</p>

<p>2013.4.11拿到了人生的第一个offer，感谢网易游戏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IKM test]]></title>
    <link href="http://sleefd.github.com/blog/2013/04/07/ikm-test/"/>
    <updated>2013-04-07T22:27:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/04/07/ikm-test</id>
    <content type="html"><![CDATA[<p>晚上做了Morgan stanley的c++在线测评，表示我又要死在这种笔试上了。
全部都是OOP概念题：继承，多态，内部类。逻辑题算法题一点都没有。<br/>
尼玛以后都不好意思说自己会c++了，丢人。<br/>
java的题不做了，估计又全部是oop概念题。</p>

<!-- more -->


<p>伤感，看来要饿补OOP部分，然后总结一下写个list贴在桌上，以后好秒杀。</p>

<p>笔试什么的，做本题库才是王道。</p>

<p>难道我今年注定投哪儿就酱油哪儿？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程珠玑之蓄水池抽样算法]]></title>
    <link href="http://sleefd.github.com/blog/2013/04/05/reservoir-sampling/"/>
    <updated>2013-04-05T11:44:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/04/05/reservoir-sampling</id>
    <content type="html"><![CDATA[<p><strong>问题来源</strong>:  编程珠玑col1,prob4.</p>

<p><strong>问题定义</strong>：从一个序列中随机取得一个数或k个不重复数</p>

<p><strong>问题求解</strong>：分两种情况：</p>

<ul>
<li>已知序列的长度n：直接使用rand()函数（发现c++0x有 <a href="http://www.cplusplus.com/reference/random/?kw=random">random</a> 头文件）</li>
<li>长度未知: 蓄水池抽样算法
（话说很愁一些算法书，总是直接给出算法，完全不知道怎么想出来的）</li>
</ul>


<!--more-->


<h3>序列长度已知</h3>

<p>1.随机获取一个数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="cp">#include&lt;cstdlib&gt;</span>
</span><span class='line'>  <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>2.随机获取k个不重复数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="cp">#include&lt;cstdlib&gt;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// 生成[i,j)间的随机数</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">randint</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">id</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">));</span><span class="c1">//swap(i,j)交换i,j下标处的两个数</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>p.s.在长度已知的情况下，该问题直观上可以用list解决。
选取一个数就从list中删掉，然后再随机生成一个下标（用初始迭代器移动到下标位置，list不支持下标操作）就ok了。</p>

<h3>序列长度未知</h3>

<p>关于蓄水池抽样算法：</p>

<blockquote><p>该算法是针对从一个序列中随机抽取不重复的k个数，保证每个数被抽取到的概率为k/n这个问题而构建的。做法是：  -<br/>
首先构建一个可放k个元素的蓄水池，将序列的前k个元素放入蓄水池中。<br/>
然后从第k+1个元素开始，以k/n的概率来决定该元素是否被替换到池子中。
当遍历完所有元素之后，就可以得到随机挑选出的k个元素。复杂度为O(n).</p></blockquote>

<p>1.随机获取一个数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//统计num的个数</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">num</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>       <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>       <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>       <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//很显然id=0的概率为1/n，也就是每个num被选到的概率是1/n</span>
</span><span class='line'>            <span class="n">res</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>2.随机获取k个不重复数</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">int</span> <span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="c1">//蓄水池</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span><span class="n">k</span> <span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="c1">//先放k个元素在蓄水池中</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>       <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>       <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//从第k+1个元素开始</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>       <span class="o">++</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>       <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span><span class='line'>       <span class="k">if</span><span class="p">(</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="p">)</span> <span class="c1">//这一步也很直观，num有k/n的概率被换到蓄水池中</span>
</span><span class='line'>            <span class="n">swap</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span><span class="c1">//把蓄水池中编号为id的数换成num</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//蓄水池中的k个数就是最终结果</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>证明每个数被取到的概率为k/n:</p>

<ol>
<li><p>对于第i个数(i&lt;k)，在前k步被选中的概率是1，
从第k+1步开始，i不被选中的概率为k/k+1,那么读到第n个数时，
第i个数(i&lt;k)被选中的概率 = 被选中的概率 * 以后每一步都不被换走的概率,即<br/>
1 * k/k+1 * k+1/k+2 <em>&#8230;</em>n-1/n = k/n</p></li>
<li><p>对于第j个数(j>=k)被选中的概率为：
在他出现时被选中的概率 * 在他出现以后不被换走的概率,即: <br/>
k/j * j /j+1 <em>。。。</em>n-1/n = k/n</p></li>
<li><p>综上得证。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++字符串分割]]></title>
    <link href="http://sleefd.github.com/blog/2013/03/24/str-split/"/>
    <updated>2013-03-24T15:42:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/03/24/str-split</id>
    <content type="html"><![CDATA[<p>文件解析，数据提取等都要用到字符串分割方法，笔试题也多有考到。</p>

<p>如果是用java语言编写的话，一般顺手就会敲出StringTokenizer，然后输入部分直接由Scanner类处理。</p>

<p>如将ip地址192.168.0.1解析成四段，可以如此写：</p>

<!-- more -->




<figure class='code'><figcaption><span>sample.java</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Sanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="s">&quot;in.txt&quot;</span><span class="o">);</span>
</span><span class='line'><span class="k">while</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">hasNextLine</span><span class="o">())</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
</span><span class='line'>    <span class="n">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">line</span> <span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="k">while</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">haxNext</span><span class="o">())</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">next</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果是用c++的话，有以下三种做法：</p>

<ol>
<li>使用cstring头文件中的strtok函数</li>
</ol>


<figure class='code'><figcaption><span>split1.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">delim</span><span class="p">[]</span> <span class="o">=</span> <span class="err">“</span><span class="p">,</span><span class="err">”</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">gets</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      <span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">delim</span> <span class="p">);</span>
</span><span class='line'>      <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>          <span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">delim</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>使用stdio.h中的sscanf</li>
</ol>


<figure class='code'><figcaption><span>split2.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&quot;%d.%d.%d&quot;</span> <span class="p">,</span><span class="o">&amp;</span><span class="n">a</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span> <span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>sscanf和sprintf是非常有用的函数，应该善用。<br/>
3.  使用strstr()或strchr()或substr()函数<br/>
用这些函数显然是通过寻找delim出现的位置，来分隔字符串。对delim是单个字符的就比较好写了，多个字符很麻烦吧。<br/>
还是以解析ip地址为例:</p>

<figure class='code'><figcaption><span>split3.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;192.168.1&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">part</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</span><span class='line'>  <span class="n">line</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span> <span class="c1">//字符串最后补一个delim，方便后面操作</span>
</span><span class='line'>  <span class="k">while</span><span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="s">&quot;.&quot;</span><span class="p">))</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>       <span class="n">len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span><span class="n">start</span><span class="p">;</span>
</span><span class='line'>       <span class="n">strncpy</span><span class="p">(</span><span class="n">part</span><span class="p">,</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>       <span class="n">part</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>  <span class="c1">//strncpy不会自动补&#39;\0&#39;</span>
</span><span class='line'>       <span class="n">start</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">part</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python入门(1)]]></title>
    <link href="http://sleefd.github.com/blog/2013/03/20/python-begin/"/>
    <updated>2013-03-20T13:15:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/03/20/python-begin</id>
    <content type="html"><![CDATA[<p>参考： http://blog.sina.com.cn/s/blog_a36b03a90101cyun.html</p>

<p>python是面向对象的，解释执行的，跨平台的，自己内存管理的脚本语言。</p>

<!-- more -->


<p><strong>弱类型语言</strong>：不需要申明变量的类型。<br/>
i,j = 3,4; #i=3,j=4</p>

<p><strong>两种变量类型</strong>：数值类型和引用类型。<br/>
除了数值之外，其他类型都是引用类型。比如list,元组等等。</p>

<h3>数值类型</h3>

<blockquote><p>long型可以是任意长度，数字常量后加l或L<br/>
复数类型: 3+4j or 3+4J</p></blockquote>

<h3>运算</h3>

<ul>
<li>四则元素： +、-、*、/、%</li>
<li>幂运算： **    &nbsp; &nbsp; 2 ** 3 = 8</li>
<li>逻辑运算： and or not</li>
<li>bool运算：is    ,   is not   ,   in ,    not in</li>
<li>位运算：&amp; | ~ ^</li>
</ul>


<h3>字符串</h3>

<ul>
<li><p>特点：<br/>
&#8221; or &#8220;&#8221; 括起来的字符序列  <br/>
r&#8217;\n&#8217; 或 R&#8217;\n&#8217;不转义字符<br/>
用&#8221;&#8220;&#8221;括起来，可包含换行字符串<br/>
与java一样字符串无法改变</p></li>
<li><p>操作：
乘法 表示重复字符串<br/>
分片:和matlab矩阵一样A[1:3]<br/>
长度: len(str)<br/>
遍历: for x in str:<br/>
格式化字符串：一种操作，like printf<br/>
(this is &#8220;%s&#8221;) %(str)</p></li>
<li><p>索引 从0开始，可以反向索引 从-1开始</p></li>
</ul>


<h3>内置复杂类型</h3>

<ul>
<li><p>列表 []括起来，元素可变，可保存任意对象，可动态增长<br/>
操作： append() /sort() index()  /reverse() / del list[1] <br/>
列表的分片，+，*操作产生新列表<br/>
  list = 1,2,3 #可省略括号</p></li>
<li><p>元组 （）括起来，非可变序列，可保存任意对象</p></li>
<li><p>字典
类似c++中的map</p>

<blockquote><p>{}括起来 {key:value, key2:value}<br/>
m.has_key()<br/>
m.keys() #返回所有键值组成的列表<br/>
m.values() #返回所有值组成的列表<br/>
len(m)<br/>
del m[k]</p></blockquote></li>
</ul>


<h3>比较</h3>

<p>== 比较字面值<br/>
is 比较引用</p>

<h3>标准输入输出：</h3>

<p>str = raw_input(&#8220;plz input something\n&#8221;);<br/>
print &#8220;hello,world&#8221;<br/>
文件读写操作： 和c相同<br/>
输入： input = open(&#8220;in.txt&#8221; , &#8220;r&#8221;);</p>

<pre><code>           s = input.read();
          s = input.read(N);
           readline();#返回string
           readlines() ; #返回list
</code></pre>

<p>输出: output = open(&#8220;out.txt&#8221; , &#8220;w&#8221;);</p>

<pre><code>     output.write(s);
     output.writelines(list);
</code></pre>

<p>output.close();</p>

<h3>流程控制</h3>

<p>if条件判断：</p>

<pre><code>if 条件：
    elif:
else:
</code></pre>

<p>while循环</p>

<pre><code>while 条件:
else:
</code></pre>

<p>for循环</p>

<pre><code>for x in str:
     do sth
else:
</code></pre>

<h3>函数定义</h3>

<p>def fun(params):
无需指明返回值，直接return 就行。<br/>
没有return时，返回none</p>

<p>python module 类似于java中的lib，里面定义一些可以被使用的函数<br/>
import module 或者from module import*</p>

<p><strong>doc</strong>文档字符串，每个对象都有这个属性，显示对象的说明文字，输出用&#8221;&#8220;&#8221;包含的内容<br/>
<strong>name</strong>模块属性：如果是调用的模块，则module.<strong>name</strong>输出模块名 如果是直接运行该模块则等于<strong>main</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用markdown写ppt]]></title>
    <link href="http://sleefd.github.com/blog/2013/03/07/markdown-ppt/"/>
    <updated>2013-03-07T20:40:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/03/07/markdown-ppt</id>
    <content type="html"><![CDATA[<h4>why markdown?</h4>

<p>最近一直用markdown写blog，深感markdown易于书写的特性。如果markdown能用于写ppt岂不是更好，再加上<a href="http://johnmacfarlane.net/pandoc/">pandoc</a>这个奇妙的工具，那么所有涉及到书写的工作基本上都可以由markdown完成了。</p>

<!-- more -->


<h4>principle</h4>

<p>偶然在Toplanguage上看到有人用<a href="https://github.com/bartaz/impress.js">impress.js</a>做的html格式的ppt，简洁而且可以直接丢在网上，感觉非常有趣。于是开始研究原理，发现其实很直观：强大的javascript+css3即可以实现很绚丽的ppt效果（其实前端开发也很有挑战性嘛~）。ppt书写可以直接由markdown,html,textile等语言完成，very nice~</p>

<p>花时间研究了一下，发现支持html ppt制作的template很多，比如deck.js,impress.js，reveal.js等等。最后找到了<a href="http://slideshow.rubyforge.org/">slideshow</a>这个ruby gem，易用而且支持上面提到的各种template，特此推荐。</p>

<h4>slideshow</h4>

<p>slideshow可以将markdown或textile等文件解析成ppt，所有的ppt页面都在一个html页中，因此你可以直接把这个html放在自己的网站上，供别人访问。</p>

<p>slideshow安装方法如下：<br/>
1. 安装ruby和ruby gems<br/>
2. gem install slideshow #安装slideshow gem</p>

<p>使用时直接 <code>slideshow test.md</code> 即可将test.md解析成test.html，双击打开就是一个ppt，方向键控制播放,F11全屏浏览，very simple.</p>

<p>与test.html同时生成的还有s6文件夹，包含s6模版文件；test.css，html样式表。<br/>
slideshow默认为s6模版。安装其他模版输入命令以deck.js为例：<br/>
&#8216;slideshow -f deck.js&#8217;</p>

<p>自己做了一个<a href="http://sleefd.github.com/denclue">demo</a>，关于密度聚类算法的ppt。<a href="http://sleefd.github.com/denclue/denclue.md">示例markdown</a>。</p>

<hr>


<p>slideshow参考:<a href="http://slideshow.rubyforge.org/">slideshow</a><br/>
推荐网站 <a href="www.rvl.io.">reveal</a>，支持在线ppt编辑，可直接生成一个在线浏览链接，非常方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译安装第三方lib]]></title>
    <link href="http://sleefd.github.com/blog/2013/02/27/use-third-library/"/>
    <updated>2013-02-27T22:08:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/02/27/use-third-library</id>
    <content type="html"><![CDATA[<h3>编译运行基本步骤</h3>

<p>./comfigure  #生成makefile，configure文件一般是Linux下可执行脚本<br/>
make  #编译<br/>
make install #安装文件<br/>
make uninstall #卸载文件</p>

<!--more-->


<h3>版本</h3>

<p>source distribution 源代码版本。第三方库或软件的源代码，需要自己编译才能使用。<br/>
源代码版本需要经过上述三个步骤才能执行。<br/>
binary distribution 二进制版本即可执行版本，已编译好的，在特点平台上可直接运行安装的。</p>

<h3>平台</h3>

<p>windows下使用源代码版本的软件或库，需要自己写makefile，然后make,make install.平时我们使用复杂的IDE如visual studio等，可以直接编译运行，不需要
自己写makefile，上述三个步骤已由IDE自己完成。</p>

<p>linux下源码包以压缩包的形式存在，需先解压，然后cd到所在目录，再输入上述三个命令即可。
注意阅读源码包中的readme和install文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程珠玑之幂函数]]></title>
    <link href="http://sleefd.github.com/blog/2013/01/27/pow/"/>
    <updated>2013-01-27T19:36:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/01/27/pow</id>
    <content type="html"><![CDATA[<p>问题来源：编程珠玑 ,column4, problem 9，修改log（n）内的递归求幂算法为迭代算法。这样才知道求幂有O(log(n))复杂度的算法，sigh。发现很多问题都可以用二分的思想来解决。</p>

<!-- more -->


<p>问题定义：求pow(x,n)，其中n为正整数。<br/>
解法一： 很直观的解法，每个人第一眼看到都会想到。将x乘以n次就ok嘛，一个for循环了事。时间复杂度O(n)。</p>

<ul>
<li>迭代求解</li>
</ul>


<figure class='code'><figcaption><span>pow1.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'> <span class="n">result</span> <span class="o">*=</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>递归求解</li>
</ul>


<figure class='code'><figcaption><span>pow2.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>解法二： pow(2 , 4)以解法一的话，需要做四次乘法，但是如果先计算2*2，再计算4*4,两次乘法ok，即log（n）次乘法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(n/2 == 0)
</span><span class='line'>      pow(x,n) = square(pow(x , n/2));
</span><span class='line'>    if(n%2 == 1)
</span><span class='line'>      pow(x,n) = x * pow(x,n-1)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>递归解法</li>
</ul>


<figure class='code'><figcaption><span>pow3.cpp</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>迭代求解</li>
</ul>


<figure class='code'><figcaption><span>pow4.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">*</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">*=</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>测试scaffolding:</p>

<figure class='code'><figcaption><span>test.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#define f pow</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="c1">// cout &lt;&lt; f(2,-1) &lt;&lt; endl; //源代码应该检查指数不为正整数的情况</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结： 二分的方法在很多地方都能使用，以后遇到算法优化，首先考虑二分。<br/>
将第二种解法的递归形式改为迭代形式我想了好久。仔细想想，递归是自顶向下的求解方法，
而迭代是自底向上的求解方法，然后枚举出所有的可能情况，就可以很好的写出递归或迭代形式的算法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[四时之景不同，而乐亦无穷也]]></title>
    <link href="http://sleefd.github.com/blog/2013/01/12/donghuxing/"/>
    <updated>2013-01-12T21:37:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2013/01/12/donghuxing</id>
    <content type="html"><![CDATA[<p>和喵环东湖一周，大概2个半小时吧，挺快的，比平时快多了。<br/>
今天东湖雾很大，一眼看不到太远，虽没有秋天的静谧，没有秋天的金棕色红色，但是薄雾笼罩下的东湖确实别有风味。环湖路上的汽车依然很多，公汽依然不客气，随意的就把我们小折叠挤到路边边。</p>

<!-- more -->


<p>今天天气算暖和了，因此骑车的人很多，折叠山地都有，普通车也有。虽有风，我依然穿了一件抓绒衣，一件马甲，魔术头巾当口罩，轻装出行，很快意。以不快不慢的速度骑行，然后不时能瞟一下湖两边的风景，人生真美好~<br/>
依然是从工学部外的那个桥骑入东湖。没走多远，就看到一对老夫妻在路边很小块的田地里耕田。老奶奶是搬个板凳坐着的，老爷爷站着翻土，画面很和谐。我依然认为乐享天伦之乐是人世间最幸福的事情。<br/>
继续往前走到梅园，正举行东湖2013年梅花节。梅园梅花的品种很多。记得同yuqi翻墙进梅园的那时，梅花还未盛开，但是梅园很静。现在梅花已开，看墙壁上挂的各种梅花图片，还是挺想进去的，但是带着车有诸多不便，于是继续向前。<br/>
然后到磨山风景区入口，有一个自动租借书籍的机器，刷武汉通就可以了，顿时觉得武汉通真好用，不仅能刷地铁还能借杂志，如果以后绕东湖乏了，还能借一两本书，在常去的那小片总是有太阳照射的草地上躺着看看，其实很美。<br/>
喵说想绕整个东湖，我也就没按平时走一部分路然后往回骑，继续向东湖海洋生态馆和听涛景区进发。竟然碰到一个背包徒步游东湖的人，同好呀。改明儿有时间我也来个徒步环东湖，在武汉也只独自一人徒步从信息学部大门一直走到长江大桥过，和小白一起从龟山走到过江滩。<br/>
过了听涛景区之后竟然有点不认识路了，只记得要经过省博一直往前走，于是在路上抓了个阿姨问问。阿姨说也刚到这儿不清楚，然后我们说去武大，她就清楚了，很耐心的为我们指了路，走的时候还不时回头嘱咐我们，所以说这个世界好人是很多的~<br/>
接着遇到一个地下通道不知道要不要下去，又问一阿姨，阿姨的自行车貌似坏了，要推着走，但是还是让我们直接从通道骑下去，不需要跟她一样推，嘿嘿。顺利骑下去然后拐弯。
绕回来的时候又到工学部旁边那条东湖路，竟然看到一个人骑着山地后面带着一个箱子，箱子里面放着他的小狗，真可爱。狗头还伸出箱子外往外望，太有爱了，哈哈。<br/>
总之，骑行过程很舒心，回来之后腰酸腿疼，各种累，某喵同学还吵着要去按摩~哈哈
心在路上，从未停止。</p>

<hr/>


<p>能走不同的路，看不同的风景，有三五好友，还有什么值得追求？<br/>
有一颗自由的心，且能时刻保持着对万物的兴趣与怜悯，还有什么值得拥有？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress博客搭建中问题汇总及解决方法]]></title>
    <link href="http://sleefd.github.com/blog/2012/12/28/build-problems/"/>
    <updated>2012-12-28T20:53:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2012/12/28/build-problems</id>
    <content type="html"><![CDATA[<ol>
<li><p>bundle install时，ffi包装不上：</p>

<p>将gemfile.lock文件中所有涉及到ffi版本号的地方都改为ffi (~>1.1.1)<a href="http://michael-roshen.iteye.com/blog/1613151">【参考】</a><!--more--></p></li>
<li><p>bundle install时，安装某个包提示<code>&gt; ERROR: Failed to build gem native extension.</code></p>

<ul>
<li><a href="http://rubyinstaller.org/downloads/">安装Devkit</a></li>
<li>配置环境变量path为devkit下的bin目录</li>
<li><p>执行代码</p>

<p><code>
ruby dk.rb init<br/>
ruby dk.rb install
</code></p></li>
</ul>
</li>
<li><p>rake generate失败</p>

<ul>
<li>检查_config.yml，注意每个冒号后面都有空格</li>
<li>大多数原因是中文解析问题。<br/>
首先所有的markdown文件应为UTF-8格式，然后修改
你ruby安装目录下的convertible.rb：<br/>
<code>
self.content = File.read(File.join(base, name))改为<br/>
self.content = File.read(File.join(base, name), :encoding => "UTF-8")
</code></li>
</ul>
</li>
<li><p>使用模版的方法：<br/>
RTFM:一定要看模版说明<br/>
通过修改_config.yml中的相关变量来基于模版个性化自己的博客。</p></li>
<li><p>使用<code>&lt;!-- more --&gt;</code>来显示post中的部分内容。该标签后的所有内容将不被显示。</p></li>
<li><p>配置disqus的方法：</p>

<ul>
<li>注册disqus id，配置与你的站点关联，取一个站点shortname，记住它，很重要。</li>
<li>设置_config.yml中disqus部分：<br/>
disqus_short_name: 站点shortname<br/>
disqus_show_comment_count: true</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mex调用c代码备忘]]></title>
    <link href="http://sleefd.github.com/blog/2012/12/28/mex/"/>
    <updated>2012-12-28T16:36:00+08:00</updated>
    <id>http://sleefd.github.com/blog/2012/12/28/mex</id>
    <content type="html"><![CDATA[<ul>
<li>目的：在matlab中调用c函数，加快代码执行速度或实现c代码复用。</li>
<li>媒介：mex file
  有约定俗成的格式，c源文件必须包括头文件 &#8220;mex.h&#8221;, 函数 mexFunction为入口函数.
  当然也可以使用其他符合c语法的函数，头文件。</li>
<li>关键： 各种数据类型在matlab和c之间的转换，传递。</li>
</ul>


<!-- more -->


<ul>
<li>mexFunction的签名为
<code>
  void mexFunction( int nlhs,
   mxArray <em>plhs[],
   int nrhs,
   const mxArray </em>prhs[])
</code>
参数解释：
  nlhs: 输出个数
  nrhs: 输入参数的个数
  plhs: 指向输出的指针数组
  prhs: 指向输入的常指针数组</li>
<li>数据类型：
  matlab传递给c的数据类型都是mxArray类型,matlab的所有数据类型内部都以mxArray的形式存储。(可以猜想mxArray是一个结构体类型。</li>
<li>基本操作：mx/mex函数

<pre><code>   1. *mx开头*的函数为对数据进行操作的函数.
      记住：有Get操作，就有对应的set操作，而且由于操作大多针对指向数据的指针，所以
      set操作可能会改变workspace中的变量。
   2. *mex开头*的函数为与workspace交互的函数，如输出error message ,warning message , printf data等。
</code></pre></li>
</ul>


<h4>代码示例</h4>

<ul>
<li>c从matlab获得数据
  获取matrix:

<pre><code>  double *p = mxGetPr(prhs[0]) ;//得到指向第一个数据参数的指针。 注意：所有包含数值的参数都是double类型。
  只要参数是matrix(m*n)类型，都可以通过mxGetPr得到指向数据的指针，数据以从上到下从左到右的形式存储。（也就是线性的~
</code></pre>

  获取维数：

<pre><code>  `mexGetM(mxarray)/mexGetN(mxarray)： 得到mxArray的row &amp;&amp; column 数`
</code></pre>

<p>  获取cell数据类型：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(int index = 0 ; index &lt; size  ; ++index)
</span><span class='line'>      {
</span><span class='line'>          mxArray * p = mxGetCell(prhs[0] , index); //得到index处的mexArray
</span><span class='line'>          double *elem = mxGetPr(p);
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<pre><code>直接获取data（数值
</code></pre>

<p>`       double *data;</p>

<pre><code>    data = mxGetData(prhs[0]);
    //mxSetData(p1hs[0] , data);
    `
</code></pre>

<ul>
<li>c返回数据给matlab

<pre><code>workspace输出：mexPrintf,类似c printf函数。  mexPrintf("%d\n" , number);
               mexErrMsgTxt,打印error消息。 mexErrMsgTxt("This is an error message.");
               mexEvalString,在workspace中调用string指定的命令。 mexEvalString("plot([1:5])"); //plot命令会被执行
</code></pre>

   想要返回数据给matlab，首先要分配空间给输出数据，这样它才能存在于当前的workspace中。

<pre><code>  分配空间的方法 1 plhs[0] = mxCreateDoubleMatrix(m,n,mxReal);
                  double *data = mxGetPr(plhs[0]); //and then you can assign values to data.
                 2 利用mxMalloc (用法类似c malloc
                  double *data = mxMalloc(sizeof(double) * num);
                      ... //assign values
                  mxSetPr(prhs , data);
</code></pre></li>
<li>动态内存分配:使用mxMalloc/mxFree mxCalloc/mxFree

<pre><code>       虽然c malloc和free也可以使用，但是会导致不可预知的错误，所以谨记使用mex functions.
</code></pre></li>
</ul>


<p>配置mex file编译环境在matlab中：</p>

<pre><code>直接在命令行下输入 mex -setup 选择合适的编译器就ok了。
</code></pre>

<p>调试：可在VS中采用附加进程调试</p>

<p>有价值的资料：</p>

<pre><code>1. apiext.pdf //matlab external interface 
2. mexguide.pdf 
</code></pre>
]]></content>
  </entry>
  
</feed>
